联机事务处理OLTP(on-line transaction processing) 以小的事务以及小的查询为主
OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易
OLTP 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作；

联机分析处理OLAP(On-Line Analytical Processing)
OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。
OLAP 系统则强调数据分析，强调SQL执行市场，强调磁盘I/O，强调分区等。

------------------------------------------
在事务并发执行时，如果不进行任何控制
脏写（Dirty Write）
脏写是指一个事务修改了其它事务未提交的数据。

1. 未提交读(Read uncommitted)
未提交读是数据库事务隔离级别中最低的一种，在这种级别下，一个事务会读到另一个事务更新后但未提交的数据，如果事务1 rollback后，那么事务2读取的数据就是脏数据，即脏读

2. 已提交读（Read Committed） (线上环境)
只能读取到已经提交的数据。在事务1内，多次读同一数据，在这个事务还没有结束时，如果事务2恰好修改了这个数据，那么，在事务1中，两次读取的数据就可能不一致。即不可重复读的问题,

3. 可重复读(Repeated Read)
可重复读就是多次读取的结果都一直，而不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。即幻读

4. 可串行化(Serializable)
可串行性是并行调度正确性的唯一准则，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。为保证并行调度可串行性而提供的封锁协议。因此我们可以得出如下结论:这个事务级别的,其并行执行的结果一定是正确的，但是呢，由于串行执行，大大降低了并行度，所以一般不使用它。

------------------------------------------

https://www.cnblogs.com/chentianming/p/13494223.html

MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。

版本链
每行记录实际上都包含了两个隐藏字段：
1. 事务id(trx_id): 每次修改某行记录时,都会把该事务的事务id赋值给trx_id隐藏列(最新的列)
2. 回滚指针(roll_pointer): 每次修改某行记录时,都会把undo日志地址赋值给roll_pointer隐藏列

对该条记录的修改日志串联起来就形成了一个版本链，版本链的头节点就是当前记录最新的值(就是undo log的roll pointer会指向上一个版本)


在MySQL中，READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。READ COMMITTED在每次读取数据前都会生成一个ReadView，这样就能保证每次都能读到其它事务已提交的数据。REPEATABLE READ 只在第一次读取数据时生成一个ReadView，这样就能保证后续读取的结果完全一致。

------------------------------------------

https://mp.weixin.qq.com/s?__biz=MzA5Mjg2MDQ5NQ==&mid=2452509174&idx=1&sn=600a3d3622927dd8234d6fd66f603665&scene=21#wechat_redirect

基本的锁有两种
1. 排它锁（写锁、X锁）
2. 共享锁（读锁、S锁）

三种锁(next key locking)

2. 意向锁
意向锁在InnoDB中是表级锁,和他的名字一样他是用来表达一个事务想要获取什么。意向锁分为:
意向共享锁:表达一个事务想要获取一张表中某几行的共享锁。
意向排他锁:表达一个事务想要获取一张表中某几行的排他锁。

除了共享锁(Shared Locks)和排他锁(Exclusive Locks)，Mysql还有意向锁(Intention Locks)。
意向锁是由数据库自己维护的,一般来说,当我们给一行数据加上共享锁之前,数据库会自动在这张表上面加一个意向共享锁(IS锁);
当我们给一行数据加上排他锁之前,数据库会自动在这张表上面加一个意向排他锁(IX锁).
意向锁可以认为是S锁和X锁在数据表上的标识,通过意向锁可以快速判断表中是否有记录被上锁,从而避免通过遍历的方式来查看表中有没有记录被上锁,提升加锁效率.
例如,我们要加表级别的X锁,这时候数据表里面如果存在行级别的X锁或者S锁的，加锁就会失败，此时直接根据意向锁就能知道这张表是否有行级别的X锁或者S锁

3. 自增长锁

4. 三种行锁
1.



防止死锁
1. 以固定的顺序访问表和行。交叉访问更容易造成事务等待回路。
2. 尽量避免大事务，占有的资源锁越多，越容易出现死锁。建议拆成小事务。
3. 降低隔离级别。如果业务允许(上面4.3也分析了，某些业务并不能允许)，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
4. 为表添加合理的索引。防止没有索引出现表锁，出现的死锁的概率会突增。

