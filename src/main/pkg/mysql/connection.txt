为什么使用连接池

1. 为什么使用长连接
当客户端需要和数据库建立连接的时候，有短连接和长连接两种选择：
短连接:只在程序和数据库通信的时候建立连接，执行操作后，连接关闭。
长连接:程序之间的连接在建立之后，就一直打开，被后续程序复用。
短连接的优点是简单，占用内存资源较小。缺点是在流量大的场景下可能产生性能问题。
长连接的优点是可复用，缺点是，维持连接需要占用内存，可能导致内存浪费。

对数据库来说，创建和销毁连接涉及到CPU的运算、资源的争用、内存的分配和socket的建立等。频繁的创建连接和销毁连接，对数据库来说是不可接受的，所以长连接显然比短连接更适合数据库。

为什么使用连接池
既然长连接更适合数据库，那么这时就出现了连接池。有了连接池，可以通过参数来配置连接数、连接检测、连接的生命周期等。可以做到连接的复用，减少平均连接时间，降级数据服务器的负载




第一层，磁盘io。
指标专业名词：IOPS；因为所有的数据都是存储在磁盘的，所以，在高并发的场景下，一定会受到磁盘能力的限制，普通磁盘 sata 可能只有7-10M/s 的能力，只要要求加载的数据远远大于这个速度，磁盘瓶颈就出来了。当然了，磁盘读取后，结果是会缓存到内存的，所以又和内存有关了！

底层存储的IOPS越高，你的数据库的并发能力就越高。

Mysql数据库磁盘IO达到100%的解决方法
问题1. 瞬时写入数据量过大。
软件设计不合理，在监控服务器上面得程序将读取到所有的数据每隔一定周期一起写入数据库，瞬间数据量过于庞大。
解决办法:
1. 软件上提出建议将程序功能分模块（采集器分类、设备分类或者等级分类）写入数据库，数据库中tables较多，分别写入可降低磁盘IO。
2. 终端读取数据库的间隔适当加长，不和写操作争抢资源。
3. 硬件上可考虑更换固态硬盘来提交读写速率。

只读锁（flush tables with read lock）后磁盘IO正常，开启写(unlock tables)后，磁盘IO脉冲式增加。说明磁盘IO增加的原因是数据库写造成的，那么就需要在写操作上优化。

问题2. 二进制日志文件mysqlbinlog过大
每天数据产生17G的二进制日志文件mysqlbinlog, 磁盘快满了
解决办法: 对于监控数据来说, 其实没有必要保存改变数据库信息的语句. expire-logs-days, 设置清除log文件的天数. 或者直接不需要, 在my.ini文件中直接关闭, 也可降低磁盘IO


问题3：数据库没有经过调优
影响数据库最大的性能问题就是磁盘IO，为了提升数据库的IOPS，可以使用SSD或者PCIE-SSD高速磁盘。内存方面也很重要，内存可以缓存热点数据和存储引擎文件，避免产生过多的物理IO，可以增加物理内存来提高数据库的并发和读写性能。

Mysql数据库参数应该怎么调优？
1. Innodb_buffer_pool_size。作用是缓存innodb表的数据信息，可以设置为物理内存的50-80%。
2. innodb_flush_log_trx_commit和。参数是redo log刷新的参数，默认是1，即在每个事务提交时，InnoDB立即将缓存中的redo日志回写到日志文件，并调用操作系统fsync刷新IO缓存。可以设置为2，即是每个事务提交时，InnoDB立即将缓存中的redo日志回写到日志文件，但并不马上调用fsync来刷新IO缓存，而是每秒只做一次磁盘IO缓存刷新操作。参数为0时，在提交事务时，InnoDB不会立即触发将缓存日志写到磁盘文件的操作，而是每秒触发一次缓存日志回写磁盘操作，并调用操作系统fsync刷新IO缓存。修改为2或者0时，可以节省IO资源，但是在崩溃或断电的时候会丢失最后一秒的数据，但对于监控数据来说没啥影响。

设为是最安全的，但性能也是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只要求性能，例如高并发写的日志服务器，设置为0来获得更高性能。

3. sync_binlog。binlog刷新的参数，默认是1。和参数innodb_flush_log_trx_commit组成数据库的双一，可以保证主从架构中数据的一致性。在监控系统中，binlog关闭了。
4. innodb_max_dirty_pages_pct。脏页占Innodb_buffer_pool的比例，，超过时触发刷脏页到磁盘，建议25%-50%。
5. innodb_io_capacity。innodb后台进程中最大的IO性能指标，影响刷脏页和插入缓冲的数量，默认200。高转速磁盘下可以适当提高该参数。SSD磁盘配置可以调整为5000-20000，PCIE-SSD高速磁盘可以调整得更高（50000)。
6. innodb_data_file_path = ibdata1:1G:autoextend。innodb表空间不要使用默认得10MB，可以调整为1G，防止高并发下数据库受影响。
7. gerenal log。全量日志建议关闭，默认是关闭的，否则日志文件会越来越大，影响性能。
https://www.jianshu.com/p/88fa62f242b6

第二层，内存。
磁盘读取出来的数据必定会放到内存进行数据运算处理，然后才能得到结果。内存的速度当然是特别快了，咱们不考虑它这方面的能力问题。但是，速度再快，没有内存空间就没办法了，就像上面的配置 4g 的内存其实稍微几个大点的数据查询，基本就装满了。而且，在一次查询完成后，还要负责将结果缓存起来。当内存运行不够的时候，cpu会进行磁盘的swap操作，将需要运算的数据换入内存，从而保证运算正常进行，但是这个操作就很慢了，从而导致正常的查询都变得缓慢起来。（索引会稍微好点，因其数据量比较小，内存swap概率也低）。 所以，低配内存将是一大致命弱点，不要期望太高；


第三层，cpu。
其实整个过程的调度都是由cpu来运筹帷幄的。只是，cpu运算速度往往都会很快，所以我们把它稍微放后点！因为前面磁盘和内存，导致cpu会不停地运算操作。另外，由于外部请求大量涌入，导致cpu要进行多线程的维护，即会有大量上下文切换，这个切换增加了cpu压力，同时也使请求的响应变差，cpu也就越来越高，直到彪升到90+%，连操作系统的调度都很困难了。所以，只会雪上加霜地，降低请求的处理能力，从而导致db直接假死！可能只有重启才能解决问题了！

第四层，网络层。
一般来说，只要数据库和应用是部署在一个内网里，那么，网络一般不会限制能力（非绝对）；但是对于一些远程数据库，就直接要小心了，比如一个数据包就是3M+，那么如果是 10Mb/s 的带宽，仅能传输3-4个数据包，从而使响应能力完全限死；所以，数据库一般需要部署内网机房，或者买云数据库时，最好在同一区。网络层一般我们可以忽略，但是要知道这里的原理！



