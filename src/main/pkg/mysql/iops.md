IOPS过高时的处理方案
针对undo/redo log 和 binlog的写入磁盘机制， mysql其实提供了参数可以进行配置：

innodb_flush_log_at_trx_commit配置
此项配置用来针对undo/redo log的磁盘写入配置。他有3个类型:
设置为0: 会每隔1秒把缓存中的undo/redo log写入到磁盘。
设置为1: 每次提交事务（一般的insert和update都有事务）写入到磁盘，该方案最安全，也是最慢的。
设置为2: 会写入系统的缓存，但会每隔一秒才调用文件系统的“flush”将缓存刷新到磁盘上去。这样mysql即使崩了，系统缓存还在，比0的方案优。

所以通过配置注释看到，如果我们可以在数据库服务器宕机的时候，允许有1秒的数据丢失，其实用设置为2是最优的方案，可以提高性能。
查看当前配置的代码：

show variables like 'innodb_flush_log_at_trx_commit';

--------------------

sync_binlog配置
此项配置用来针对binlog的磁盘写入配置，可以用来配置合并多少条binlog一次性写入磁盘。
设置为0：代表依赖系统执行合并写入。
设置为1：代表每次提交事务后都需要写入，方案最安全，也是最慢的。
设置为N（一般100-1000）： 代表每N条后，合并写入磁盘。

针对sync_binlog，同样允许数据库服务器宕机的情况下能接受丢失N条数据的， 可以配置为N，能提高性能。

查看当前配置的代码：
    show variables like 'sync_binlog';
设置的代码(立即生效，无需重启)：
    set global sync_binlog=100;

关系型数据库最注重的是ACID特性，按照优化的配置也就破坏了这个特性，所以有利的时候同时也存在着弊端，只适合数据允许接收丢失的情况。如果实在不能接收丢失，只要依靠分布式的方式，也就是增加处理能力，来支持业务所需的IOPS。

qjl的设置都是1
活动规格
规格：16核128 GB
磁盘：102400GB
32000

为什么使用连接池

1. 为什么使用长连接
当客户端需要和数据库建立连接的时候，有短连接和长连接两种选择：
短连接:只在程序和数据库通信的时候建立连接，执行操作后，连接关闭。
长连接:程序之间的连接在建立之后，就一直打开，被后续程序复用。
短连接的优点是简单，占用内存资源较小。缺点是在流量大的场景下可能产生性能问题。
长连接的优点是可复用，缺点是，维持连接需要占用内存，可能导致内存浪费。

对数据库来说，创建和销毁连接涉及到CPU的运算、资源的争用、内存的分配和socket的建立等。频繁的创建连接和销毁连接，对数据库来说是不可接受的，所以长连接显然比短连接更适合数据库。

为什么使用连接池
既然长连接更适合数据库，那么这时就出现了连接池。有了连接池，可以通过参数来配置连接数、连接检测、连接的生命周期等。可以做到连接的复用，减少平均连接时间，降级数据服务器的负载




第一层，磁盘io。
指标专业名词：IOPS；因为所有的数据都是存储在磁盘的，所以，在高并发的场景下，一定会受到磁盘能力的限制，普通磁盘 sata 可能只有7-10M/s 的能力，只要要求加载的数据远远大于这个速度，磁盘瓶颈就出来了。当然了，磁盘读取后，结果是会缓存到内存的，所以又和内存有关了！

底层存储的IOPS越高，你的数据库的并发能力就越高。

Mysql数据库磁盘IO达到100%的解决方法
问题1. 瞬时写入数据量过大。
软件设计不合理，在监控服务器上面得程序将读取到所有的数据每隔一定周期一起写入数据库，瞬间数据量过于庞大。
解决办法:
1. 软件上提出建议将程序功能分模块（采集器分类、设备分类或者等级分类）写入数据库，数据库中tables较多，分别写入可降低磁盘IO。
2. 终端读取数据库的间隔适当加长，不和写操作争抢资源。
3. 硬件上可考虑更换固态硬盘来提交读写速率。

只读锁（flush tables with read lock）后磁盘IO正常，开启写(unlock tables)后，磁盘IO脉冲式增加。说明磁盘IO增加的原因是数据库写造成的，那么就需要在写操作上优化。

问题2. 二进制日志文件mysqlbinlog过大
每天数据产生17G的二进制日志文件mysqlbinlog, 磁盘快满了
解决办法: 对于监控数据来说, 其实没有必要保存改变数据库信息的语句. expire-logs-days, 设置清除log文件的天数. 或者直接不需要, 在my.ini文件中直接关闭, 也可降低磁盘IO


问题3：数据库没有经过调优
影响数据库最大的性能问题就是磁盘IO，为了提升数据库的IOPS，可以使用SSD或者PCIE-SSD高速磁盘。内存方面也很重要，内存可以缓存热点数据和存储引擎文件，避免产生过多的物理IO，可以增加物理内存来提高数据库的并发和读写性能。

Mysql数据库参数应该怎么调优？
1. Innodb_buffer_pool_size。作用是缓存innodb表的数据信息，可以设置为物理内存的50-80%。
2. innodb_flush_log_trx_commit和。参数是redo log刷新的参数，默认是1，即在每个事务提交时，InnoDB立即将缓存中的redo日志回写到日志文件，并调用操作系统fsync刷新IO缓存。可以设置为2，即是每个事务提交时，InnoDB立即将缓存中的redo日志回写到日志文件，但并不马上调用fsync来刷新IO缓存，而是每秒只做一次磁盘IO缓存刷新操作。参数为0时，在提交事务时，InnoDB不会立即触发将缓存日志写到磁盘文件的操作，而是每秒触发一次缓存日志回写磁盘操作，并调用操作系统fsync刷新IO缓存。修改为2或者0时，可以节省IO资源，但是在崩溃或断电的时候会丢失最后一秒的数据，但对于监控数据来说没啥影响。

设为是最安全的，但性能也是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只要求性能，例如高并发写的日志服务器，设置为0来获得更高性能。

3. sync_binlog。binlog刷新的参数，默认是1。和参数innodb_flush_log_trx_commit组成数据库的双一，可以保证主从架构中数据的一致性。在监控系统中，binlog关闭了。
4. innodb_max_dirty_pages_pct。脏页占Innodb_buffer_pool的比例，，超过时触发刷脏页到磁盘，建议25%-50%。
5. innodb_io_capacity。innodb后台进程中最大的IO性能指标，影响刷脏页和插入缓冲的数量，默认200。高转速磁盘下可以适当提高该参数。SSD磁盘配置可以调整为5000-20000，PCIE-SSD高速磁盘可以调整得更高（50000)。
6. innodb_data_file_path = ibdata1:1G:autoextend。innodb表空间不要使用默认得10MB，可以调整为1G，防止高并发下数据库受影响。
7. gerenal log。全量日志建议关闭，默认是关闭的，否则日志文件会越来越大，影响性能。
https://www.jianshu.com/p/88fa62f242b6

第二层，内存。
磁盘读取出来的数据必定会放到内存进行数据运算处理，然后才能得到结果。内存的速度当然是特别快了，咱们不考虑它这方面的能力问题。但是，速度再快，没有内存空间就没办法了，就像上面的配置 4g 的内存其实稍微几个大点的数据查询，基本就装满了。而且，在一次查询完成后，还要负责将结果缓存起来。当内存运行不够的时候，cpu会进行磁盘的swap操作，将需要运算的数据换入内存，从而保证运算正常进行，但是这个操作就很慢了，从而导致正常的查询都变得缓慢起来。（索引会稍微好点，因其数据量比较小，内存swap概率也低）。 所以，低配内存将是一大致命弱点，不要期望太高；


第三层，cpu。
其实整个过程的调度都是由cpu来运筹帷幄的。只是，cpu运算速度往往都会很快，所以我们把它稍微放后点！因为前面磁盘和内存，导致cpu会不停地运算操作。另外，由于外部请求大量涌入，导致cpu要进行多线程的维护，即会有大量上下文切换，这个切换增加了cpu压力，同时也使请求的响应变差，cpu也就越来越高，直到彪升到90+%，连操作系统的调度都很困难了。所以，只会雪上加霜地，降低请求的处理能力，从而导致db直接假死！可能只有重启才能解决问题了！

第四层，网络层。
一般来说，只要数据库和应用是部署在一个内网里，那么，网络一般不会限制能力（非绝对）；但是对于一些远程数据库，就直接要小心了，比如一个数据包就是3M+，那么如果是 10Mb/s 的带宽，仅能传输3-4个数据包，从而使响应能力完全限死；所以，数据库一般需要部署内网机房，或者买云数据库时，最好在同一区。网络层一般我们可以忽略，但是要知道这里的原理！








Threads_cached	57	The number of threads in the thread cache
Threads_connected	1268	The number of currently open connections.
Threads_created	31715	The number of threads created to handle connections.
Threads_running	1	The number of threads that are not sleeping.

thread_cache_size的意义：每创建一个链接，都须要一个线程来与之匹配，此参数用来缓存空闲的线程，以致不被销毁，若是线程缓存中有空闲线程，这时候若是创建新链接，MYSQL就会很快的响应链接请求。
mysql创建链接很是消耗资源，因此就有了thread_cache，当已有链接再也不使用以后，mysql server不是直接断开链接，而是将已有链接转入到thread_cache中，以便下次在有create thread的需求时，能够在cache中复用，提升性能，下降资源消耗。
threads_cached :表明当前此时此刻线程缓存中有多少空闲线程。
Threads_connected :表明当前已创建链接的数量，由于一个链接就须要一个线程，因此也能够当作当前被使用的线程数。
Threads_created :表明从最近一次服务启动，已建立线程的数量。
Threads_running :表明当前激活的（非睡眠状态）线程数。并非表明正在使用的线程数，有时候链接已创建，可是链接处于sleep状态，这里相对应的线程也是sleep状态。
四者之间的关系：
running和其余三个状态关系不大，但确定不会超过thread_connected
(new_con-old_con)=create+(old_cache-new_cache)
从上面公式能够看出，若是create等于0，那么thread_connected减小的和thread_cached增长的相等，thread_connected增长的和thread_cached减小的相等。（其实这也就是thread_cached存在的意义，资源能够复用）













----------------------------------

UUID 主键有什么问题
目前存储引擎使用InnoDB， 将表中的数据存储在 B+ 树中，在数据库中我们称之为聚集索引。聚集索引自动将数据行按主键顺序存储。由于UUID的无序性，存储数据时会发生随机io

当你插入一行随机主键值的数据，InnoDB 需要找到这行应该属于哪一页，如果页没在缓冲池中则将其加载进缓冲池，插入数据行，最后将脏页刷回磁盘。纯随机值加上大表使得 B 树上的每个叶子节点都有机会插入行，而没有热点数据页。数据行不按照主键顺序（主键顺序指主键顺序的末端）插入会导致页的分裂，进一步导致页的填充因子降低。在缓冲池中，有新数据插入的页称为脏页。而缓冲池中的页在被刷回磁盘前再次有新数据需要写入的概率很低。所以大部分时间中，每次插入操作会导致两次 IO 过程——一次读取和一次写入。所以首先 UUID 会对 IO 操作的造成一定影响。

当然上面的过程只是描述了主键索引的构建保存，其他索引如果是无序的同样存在随机io的问题。所以索引越多也会降低插入数据的速度

自增整型主键的优势
字段长度较uuid小很多，目前考虑可以使用bigint或者int类型，而且辅助索引叶子节点存储的主键数据变少，可以减少部分存储空间。

在写的方面，因为是自增的，所以主键是趋势自增的，通俗的讲也就是说新增的数据永远在后面，会产生顺序io，这点对于性能有很大的提升


2.4 可能的潜在问题
高并发的情况下，竞争自增锁会降低数据库的吞吐能力（todo）

后期如果考虑数据迁移，或者重新分表，自增主键可能会有冲突，可以考虑使用有序uuid作为主键或者使用自增主键的同事增加一个uuid作为业务上的唯一标识

----------------------------------


压力测试过程中，如果因为资源使用瓶颈等问题引发最直接性能问题是业务交易响应时间偏大，TPS逐渐降低等。而问题定位分析通常情况下，
1. 最优先排查的是监控服务器资源利用率，例如先用TOP 或者nmon等查看CPU、内存使用情况，
2. 然后在排查IO问题，例如网络IO、磁盘IO的问题。 如果是磁盘IO问题，一般问题是SQL语法问题、MYSQL参数配置问题、服务器自身硬件瓶颈导致IOPS吞吐率问题。

1. 打开日志跟踪引起的磁盘IO问题
例如：MySQL的日志包括错误日志（ErrorLog），更新日志（UpdateLog），二进制日志（Binlog），查询日志（QueryLog），慢查询日志（SlowQueryLog）等，正常情况下，在生产系统或者压力测试环境中很少有系统会时时打开查询日志。因为查询日志打开之后会将MySQL中执行的每一条Query都记录到日志中，会该系统带来比较大的IO负担，而带来的实际效益却并不是非常大。

2. SQL写法问题引起磁盘IO高
例如：曾经在做某一个项目时，在看到数据库磁盘IO使用率偏高，前端查询业务交易loadrunner显示事物响应时间偏长，通过监控工具抓取对应SQL，通过计划分析，发现该SQL 中使用distinct 又多表关联且是大表、然后使用order by，最终显示10笔数据，而在产生中间过程数据进行筛选时，使用的是临时表，并把数据放入临时表中，内存刚好设置不大，于是放到磁盘中导致IO偏高。

备注: MySQL在执行SQL查询时可能会用到临时表，临时表存储，MySQL会先创建内存临时表，但内存临时表超过配置指定的值后，MySQL会将内存临时表导出到磁盘临时表；

-----------------------------------

MySQL 实例在日常使用中会出现实例 IOPS 使用率高的情况 原因:
1. 实例内存满足不了缓存数据或排序等需要，导致产生大量的物理 IO。
2. 查询执行效率低，扫描过多数据行。



thread_cache_size的意义：每创建一个链接，都须要一个线程来与之匹配，此参数用来缓存空闲的线程，以致不被销毁，若是线程缓存中有空闲线程，这时候若是创建新链接，MYSQL就会很快的响应链接请求。
mysql创建链接很是消耗资源，因此就有了thread_cache，当已有链接再也不使用以后，mysql server不是直接断开链接，而是将已有链接转入到thread_cache中，以便下次在有create thread的需求时，能够在cache中复用，提升性能，下降资源消耗。

threads_cached :表明当前此时此刻 `线程缓存` 中有多少空闲线程。

Threads_connected :表明当前已创建链接的数量，由于一个链接就须要一个线程，因此也能够当作当前被使用的线程数。
Threads_created :表明从最近一次服务启动，已建立线程的数量。
Threads_running :表明当前激活的（非睡眠状态）线程数。并非表明正在使用的线程数，有时候链接已创建，可是链接处于sleep状态，这里相对应的线程也是sleep状态。

四者之间的关系:
running和其余三个状态关系不大，但确定不会超过thread_connected
(new_con-old_con)=create+(old_cache-new_cache)
从上面公式能够看出，若是create等于0，那么thread_connected减小的和thread_cached增长的相等，thread_connected增长的和thread_cached减小的相等。（其实这也就是thread_cached存在的意义，资源能够复用）





排查思路
线上遇到连接数溢出的问题，问题的排查步骤？

1. 查看实例配置（几核几G、支持的最大连接数）
2. 查看当前连接数（show processlist）
3. 排查是什么动作占用了这些连接
4. 分析连接被占用的原因
    1. 慢SQL（缺索引、join太多、查询数据没有分页等）
    2. 长事务
    3. 死锁


==================================================

--------------------------------------


QPS(Query Per Second,既每秒请求、查询次数)
show global status like "Questions";
show global status like "Uptime";

获取这个指标值也很容易在MySQL中执行status命令就可以看到了.不过这个值是在MySQL生命周期内全局指标,可我们的系统不是每时每刻都在忙碌,那么在系统峰值时QPS又是多少,我们只能自己动手算了.当我们执行status的时候有个Questions,尽管它也是全局指标.不过我们可以每隔一秒查询下这个值,并将相邻的两值相减,得到的就是精确的每一秒的实际请求数了.如果MySQL处于繁忙的状态,那么我们获取的值就可以视为MySQL QPS的峰值响应能力了

--------------------------------------

TPS(Transcantion Per Second,既每秒事务数) 至于TPS嘛...
同样是衡量数据库的重要指标.不过MySQL不是每个存储引擎都支持事务.所以就拿InnoDB来说好了
TPS主要涉及提交和回滚
TPS = (Com_commit + Com_rollback) / Seconds

show global status like "Com_commit";
show global status like "Com_rollback";

--------------------------------------


总结:
如果IOPS过高，分析原因：
1. 内存不足，查询数据较多（一般为慢查询，但有时候并不是，单纯的查询数据较多），特别关注一下数据量大还需要排序的分页的，不能通过内存一次完成查询，产生大量的io操作
2. 前面几种情景都没有问题，那可能是你的写操作过多了，从代码、业务或者架构考虑优化
3. 最后的办法..提升mysql、硬件服务器的iops配置，说白了就是换硬件比如机械磁盘换固态

在业务量级没有明显变化的时候主要排查1,2,可以通过优化sql或者对数据量较大的表进行分表处理，3就不说了就是花钱换速度

如果QPS过高，分析原因：
1. 这个一般没什么解决办法，很直观的指标，你的数据库访问次数过多了，可以通过缓存减少查询次数、消息队列削峰等

如果TPS过高，分析原因：
1. 一般也是直观的写操作过度了
2. 也可能是大量的写操作发生回滚


https://cloud.tencent.com/developer/article/1505255

==================================================

awk 获取mysql监控数据
https://blog.51cto.com/u_15127579/2726979


==================================================
mysql 指标
临时表数量:
Created_tmp_disk_tables 每秒创建磁盘临时表的次数

执行次数:
Com_select/s: 平均每秒select语句执行次数
Com_insert/s: 平均每秒insert语句执行次数
Com_update/s: 平均每秒update语句执行次数
Com_delete/s: 平均每秒delete语句执行次数
Com_delete_multi 记录多表delete语句执行的次数
eg: delete tb1,tb2 from tb1,tb2 where tb1.id=tb2.id
Com_insert_select: 记录INSERT INTO TABLE table1 SELECT * FROM table2 语句执行的次数
Com_update_multi:
update tb1,tb2 set tb1.id = tb1.id+1, tb2.name='test' where tb1.id=tb2.id;
记录UPDATE tablename1, tablename2... SET... 语句执行的次数;


InnoDB Data 读写吞吐量(KB)
平均每秒读取的数据量： innodb_data_read/s
平均每秒写入的数据量： innodb_data_written/s


InnoDB Buffer Pool 请求次数
平均每秒读的请求数:innodb_buffer_pool_read_requests
平均每秒向缓冲池写的请求数:innodb_buffer_pool_write_requests/s

InnoDB Buffer Pool 命中率
缓冲池的利用率:( 1 - innodb_buffer_pool_pages_free / innodb_buffer_pool_pages_total) * 100
缓冲池中的脏块百分比: innodb_buffer_pool_pages_dirty/innodb_buffer_pool_pages_total
展示所选择节点的缓冲池的脏块率、读命中率、利用率。来源于show global status命令查询结果中的Innodb_buffer_pool_pages_dirty、Innodb_buffer_pool_pages_total、Innodb_buffer_pool_reads、Innodb_buffer_pool_read_requests等指标。


InnoDB redo 写次数
1. mysql.innodb_log_write_requests 平均每秒日志写请求次数
2. mysql.innodb_log_writes 平均每秒向日志文件的物理写次数
3. mysql.innodb_os_log_fsyncs 平均每秒向日志文件完成fsync()写数量


Q: 当集群无业务流量时，为何性能监控中的QPS还显示为大约10次/秒？
A: 因为系统后台存在监控、日志采集以及管控任务，大概每秒会产生10个左右的查询请求，对集群运行基本无影响。

Q: CPU使用率过高时，应该如何解决？
A: 建议您按如下步骤进行排查：
1. 确认是否有大量慢请求，建议优化慢SQL后再进行测试。如何查看和优化慢SQL，请参见慢SQL。
2. 确认CPU曲线是否与QPS或TPS曲线走向一致，若一致，说明该问题是事务高并发导致，可以考虑升级集群配置。
3. 若没有慢请求，CPU曲线与QPS或TPS曲线走向也不一致，请提交工单联系技术支持解决。

Q: 当前连接数远大于活跃连接数时，应该如何解决？
A: 您可以尝试将wait_timeout和interactive_timeout参数值设置的小一些以加速空闲连接的释放。但建议最好在业务端使用完连接后及时关闭回收以减少空闲连接的存在。
interactive_timeout和wait_timeout：在连接空闲阶段(sleep)起作用
即使没有网络问题，也不能允许客户端一直占用连接。对于保持sleep状态超过了wait_timeout（或interactive_timeout，取决于client_interactive标志）的客户端，MySQL会主动断开连接。

https://help.aliyun.com/document_detail/68555.html?utm_content=g_1000230851&spm=5176.20966629.toubu.3.f2991ddcpxxvD1#title-d4b-8ia-hnh

