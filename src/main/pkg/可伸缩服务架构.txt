================
分表
================
垂直拆分:拆列(宽表拆长表)
水平拆分:拆行(减小单表查询体积)

如何分片:
1. 代理分片(Mycat), 代理服务器配置路由规则
2. 定制jdbc协议: shardingJDBC

难点
1. 分布式事务
2. join

================
缓存
================
使用缓存一定会牺牲一致性来换取高性能, 就看牺牲多少一致性来换取高性能了

12306峰值承载 10W qps 的余票查询, 查询结果容忍5秒内的滞后

tomcat默认一台吞吐量5000/s, 则tomcat需要 10w/5000 = 20
redis默认一台吞吐量 5w/s, 则redis需要 10w/5000 = 2
5秒的滞后: 允许5s的时间窗口, 系统可以提供5s的不一致行为


缓存适合:
1. 读密集型
2. 存在热数据的应用(避免频繁查询)
3. rt要求较低
4. 一致性要求不严格
5. 分布式锁
不适合
1. 读少
2. 更新频繁
3. 一致性要求严格



从cpu到     大约需要的时钟周期(cycle)
寄存器       1
L1          3~4
L2          10~20
L3          40~45
内存         120~240
缓存行的单位是64bit(8byte), L2包括了L1的miss周期, L3包括了L2的miss周期
内存访问还有TLB(虚地址页表缓存)miss的情况, 会增加少量周期

8WAY, 16WAY描述缓存, 就是访问时通过物理地址的高位和中位, 从列(WAY)和行(SET)中选一个缓存单元

todo: tlb
todo: 死锁解除条件
todo: hot region
todo: mongodb

redis: rdb, aof
redis高可用: 哨兵

===========================
分布式定时任务
===========================
分布式定时任务: 将集群中分散的, 可靠性差的定时任务统一化管理和调度, 并实现分布式部署的管理方式
分布式定时任务框架: 分布式环境中防止多节点同时执行相同任务时数据被重复处理的框架
主要分为
1. 抢占式: 谁先获得资源谁就能执行
2. 协同式: 单个任务处理的数据均分到多个JVM中处理,提高数据的并行处理能力

特点:
1. 高可用: 一个节点挂掉其他节点还可以使用, 没有SPF
2. 可伸缩性: 支持弹性伸缩, 可以动态增加删除节点, 可以通过控制台部署和管理定时任务
3. 负载均衡: 通过集群的方式进行管理调度,
4. 失效转移: 任务都可以持久化到数据库或者文件系统中, 避免了宕机和数据丢失带来的隐患, 同时完善任务失败重做机制和详细的任务跟踪及告警策略




