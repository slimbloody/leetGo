### 内存分配 ###
1. 对象所需的内存，在对象的类被解析加载进入元空间之后，就可以在分配内存创建前计算出来。假设现在我们自己来设计堆内存分配，一种最简单的实现方式就是线性分配，也被称为撞针分配(bump-the-pointer)

### 对象分配到哪里 ###

### 三色标记法 (tri-color marking)算法 ###
https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247492701&idx=1&sn=ca55cd725826ae9e9c9bf953091c90d9&chksm=c2b1aca0f5c625b613a02188259fd000d85959ec83184c94d58dc61f4703e20ae89fcde2f163&token=825453317&lang=zh_CN#rd

引用计数，给对象添加一个计数器，每当有地方引用它计数器就+1，反之引用失效时就-1，那么计数器值为0的对象就是可以回收的对象，但是有一个问题就是循环引用的话无法解决。

对于现在的虚拟机来说，主要用的算法是可达性分析算法。

首先定义GC ROOTS根对象集合,通过GC ROOTS向下搜索,搜索的过程走过的路径称作引用链,如果某个对象到GC ROOTS没有任何引用链,那么就是对象不可达,是可以被回收的对象

todo:
不可达对象需要进行两次标记，第一次发现没有引用链相连，会被第一次标记，如果需要执行finalize()方法，之后这个对象会被放进队列中等待执行finalize()，如果在finalize()中成功和引用链上的其他对象关联，就会被移出可回收对象集合。（但是不建议使用finalize()方法）

finalize. 它的工作原理"应该"是这样的: 一旦垃圾回收器准备好释放对象占用的存储空间, 将首先调用其 finalize() 方法，并且在下一次垃圾回收动作发生时, 才会真正回收对象占用的内存. 所以要是你打算用 finalize(), 就能在"垃圾回收时刻"做一些重要的清除工作


不建议用finalize方法完成"非内存资源"的清理工作,
但建议用于:
1. 清理本地对象(通过JNI创建的对象)
2. 作为确保某些非内存资源(如Socket、文件等)释放的一个补充: 在finalize方法中显式调用其他资源释放方法



分代收集它的实现建立于两个假说:
1. 绝大多数对象都是朝生夕死的
2. 熬过越多次垃圾回收的对象越难死亡




按照我们上文所说的使用可达性分析算法来判断对象的存活，那么假如我们进行MinorGC，会不会有对象被老年代引用着？进行OldGC会不会又有对象被年轻代引用着？
如果是的话，那我们进行MinorGC的时候不光要管GC Roots，还有再去遍历老年代，这个性能问题就很大了。

因此，又来了一个假说:
    跨代引用相对于同代引用来说仅占极少数。

由此就产生了一个新的解决方案，我们不用去扫描整个老年代了，只要在年轻代建立一个数据结构，叫做记忆集Remembered Set，他把老年代划分为N个区域，标志出哪个区域会存在跨代引用。

以后在进行MinorGC的时候，只要把这些包含了跨代引用的内存区域加入GC Roots一起扫描就行了。



卡表实际上就是记忆集的一种实现方式，如果说记忆集是接口的话，那么卡表就是他的实现类。

对于HotSpot虚拟机来说，卡表的实现方式就是一个字节数组。

CARD_TABLE [this address >> 9] = 0;

这段代码代表着卡表标记的的逻辑。实际上卡表就是映射了一块块的内存地址，这些内存地址块称为卡页，从代码可以看出每个卡页的大小就是2^9=512字节。

只要一个卡页内的对象存在一个或者多个跨代对象指针，就将该位置的卡表数组元素修改为1，表示这个位置为脏，没有则为0。
在GC的时候，就直接把值为1对应的卡页对象指针加入GC Roots一起扫描即可。
有了卡表，我们就不需要去在发生MinorGC的时候扫描整个老年代了，性能得到了极大的提升。


卡表的问题
1. 写屏障
卡表的数组元素要修改成1，也就是脏的状态，对于HotSpot来说是通过写屏障来实现的，实际上就是在其他分代引用了当前分代的对象时候，在对引用进行赋值的时候进行更新，更新的方式类似AOP的切面思想。
2.伪共享 
缓存行通常来说都是64字节，一个卡表元素1个字节，占用的卡页内存大小就是64*512=32KB的大小。
如果多线程刚好更新刚好处于这32KB范围内的对象，那么就会对性能产生影响。

怎么解决伪共享问题？
JDK7之后新增了一个参数-XX:+UseCondCardMark，他代表是否开启卡表更新的判断，没有被标记过才标记为脏。
if (CARD_TABLE [this address >> 9] != 0)
    CARD_TABLE [this address >> 9] = 0;


### 三色标记法 ###
卡表解决了跨代收集和根节点枚举的性能问题。而有了这些措施实际上枚举根节点这个过程造成的STW停顿已经属于可控范围。

另外还存在一个问题就是接下来从GC Roots开始遍历，怎么才能高效的标记这些对象，这就是三色标记法的作用了。因为如果堆内的对象越多，那么显然标记产生的停顿时间就越长。


以现在我们熟知的CMS或者G1来举例，GC的前两个步骤如下：
    1. 初始标记：标记GC ROOT能关联到的对象，这一步需要STW，但是停顿的时间很短。
    2. 并发标记：从GCRoots的直接关联对象开始遍历整个对象图的过程，这个时间会比较长，但是现在是可以和用户线程并发执行的，这个效率的问题就是三色标记关注的问题。

在三色标记法中，把从GC Roots开始遍历的对象标记为以下三种颜色：
    1. 白色，在刚开始遍历的时候，所有的对象都是白色的
    2. 灰色，被垃圾回收器扫描过，但是至少还有一个引用没有被扫描
    3. 黑色，被垃圾回收器扫描过，并且这个对象的引用也全部都被扫描过，是安全存活的对象


### 三色标记的问题 ###
