https://nyimac.gitee.io/2020/07/03/JVM%E5%AD%A6%E4%B9%A0/#%E4%B8%B2%E8%A1%8C
================
运行期优化
================

===================
jit(Java-In-Time Compiler)
===================
字节码被反复使用, 到达一定阈值以后, 会

0层:解释执行,用解释器将字节码翻译为机器码: 默认开启性能监控功能(Profiling),如果不开启,可触发第二层编译
1层: 使用 C1 即时编译器编译执行(不带 profiling): 将字节码编译为本地代码,进行简单,可靠的优化,不开启 Profiling
2层: 使用 C1 即时编译器编译执行(带基本的profiling): 开启 Profiling，仅执行带方法调用次数和循环回边执行次数 profiling 的 C1 编译
3层: 使用 C1 即时编译器编译执行(带完全的profiling): 执行所有带 Profiling 的 C1 编译
4层: 使用 C2 即时编译器编译执行: 也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化

profiling:
运行过程中手机一些程序执行状态的数据, eg: 方法的调用次数, 循环的回边执行次数

即时编译器（JIT）与解释器的区别
1. 解释器
  1. 将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释
  2. 是将字节码解释为针对所有平台都通用的机器码
2. 即时编译器
  1. 将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译
  2. 根据平台类型，生成平台特定的机器码

对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码, 我们则可以将其编译成机器码，以达到理想的运行速度. 执行效率上简单比较一下 Interpreter < C1 < C2, 总的目标是发现热点代码(hotspot名称的由来), 并优化这些热点代码


主要的热点代码识别方式是热点探测(Hot Spot Detection)，有以下两种：
1. 基于采样方式探测（Sample Based Hot Spot Detection）：周期性检测各个线程的栈顶，发现某个方法经常出现在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。
2. 基于计数器的热点探测（Counter Based Hot Spot Detection）：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。

在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器(记录一个方法被调用次数)和回边计数器(循环的运行次数)。


逆优化
逆优化意味着编译器不得不 “撤销” 之前的某些编译；结果是应用的性能降低——至少是直到编译器重新编译相应代码为止。有两种逆优化的情形：

1. 代码被丢弃（made not entrant）
2. 产生僵尸代码（made zombie）
当编译后的代码，因为后续没有用到而被GC回收，全部回收之后，编译器就会注意到，这些代码现在适合标记为僵尸代码了。

代码缓存，编译后的代码会保存在大小固定的代码缓存中。如果发现僵尸代码，这意味着这些有问题的代码可以从代码缓存中移除，腾出空间给其他将被编译的代码（或者限制 JVM 之后需要分配的内存量）


如果Code Cache区域用满了，就会停止JIT编译, 也就是说JVM不再编译任何代码。
我们还会收到 “CodeCache is full… The compiler has been disabled” 之类的告警消息。

https://renfufei.blog.csdn.net/article/details/115165919?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-115165919-blog-106157469.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-115165919-blog-106157469.nonecase&utm_relevant_index=1
如果将其开启(-XX:+UseCodeCacheFlushing)，则会在满足以下条件时释放占用的区域:
1. code cache用满; 如果该区域的大小超过某个阈值, 则会刷新。
2. 自上次清理后经过了一定的时间间隔
3. 预编译的代码不够热。 对于每个JIT编译的方法，JVM都会有一个热度跟踪计数器。 如果计数器的值小于动态阈值，则JVM会释放这段预编译的代码。

所以jvm虚拟机叫 hotspot

https://www.cnblogs.com/JeffreyZhao/archive/2009/04/01/tail-recursion-explanation.html#:~:text=%E5%B0%BE%E9%80%92%E5%BD%92%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%20%E5%B0%BE%E9%80%92%E5%BD%92%EF%BC%8C%E5%8D%B3%E6%98%AF%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%94%BE%E5%9C%A8%E6%96%B9%E6%B3%95%E6%9C%AB%E5%B0%BE%E7%9A%84%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A6%82%E7%BB%8F%E5%85%B8%E7%9A%84%E9%98%B6%E4%B9%98%EF%BC%9A%20int%20FactorialTailRecursion%20%28int%20n%2C%20int%20acc%29,%28n%20-%201%2C%20acc%20%2A%20n%29%3B%20%7D%20%E7%94%B1%E4%BA%8E%E9%80%92%E5%BD%92%E5%9C%A8%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AB%E5%B0%BE%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%B7%B2%E7%BB%8F%E6%AF%AB%E6%97%A0%E7%94%A8%E5%A4%84%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%8C%E5%85%A8%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%85%B6%E2%80%9C%E5%A4%8D%E7%94%A8%E2%80%9D%EF%BC%8C%E5%B9%B6%E6%8A%8A%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%E4%B8%BA%E2%80%9C%E5%BE%AA%E7%8E%AF%E2%80%9D%E6%96%B9%E5%BC%8F%EF%BC%9A
尾递归，即是递归调用放在方法末尾的递归方式，如经典的阶乘
int FactorialTailRecursion(int n, int acc) {
    if (n == 0) return acc;
    return FactorialTailRecursion(n - 1, acc * n);
}

由于递归在方法的末尾，因此方法中的局部变量已经毫无用处，编译器完全可以将其“复用”，并把尾递归优化为“循环”方式：
int FactorialLoopOptimized(int n, int acc) {
    while (true) {
        if (n == 0) {
          return acc;
        }

        acc *= n;
        n--;
    }
}

JIT 编译运用了一些经典的编译优化技术来实现代码的优化，即通过一些例行检查优化，可以智能地编译出运行时的最优性能代码。主要有两种：方法内联、逃逸分析。
----------------------
逃逸分析
----------------------

逃逸分析: 逃逸分析是一种确定指针动态范围的方法——分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析。
如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中被访问到的地方无法确定——这样指针就成功“逃逸”了。如果指针存储在全局变量或者其它数据结构中，因为全局变量是可以在当前子程序之外访问的，此时指针也发生了逃逸。
逃逸分析确定某个指针可以存储的所有地方，以及确定能否保证指针的生命周期只在当前进程或在其它线程中。

JVM判断新创建的对象是否逃逸的依据有：
1. 对象被赋值给堆中对象的字段和类的静态变量。
2. 对象被传进了不确定的代码中去运行


对象逃逸状态
1. 全局逃逸（GlobalEscape）
  即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：
  1. 对象是一个静态变量
  2. 对象是一个已经发生逃逸的对象
  3. 对象作为当前方法的返回值
2. 参数逃逸（ArgEscape）
  即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的
3. 没有逃逸

当判断出对象不发生逃逸时，编译器可以使用逃逸分析的结果作一些代码优化
1. 将堆分配转化为栈分配。如果某个对象在子程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，而不是在堆上。在有垃圾收集的语言中，这种优化可以降低垃圾收集器运行的频率。
  方法栈上的对象在方法执行完之后，栈桢弹出，对象就会自动回收。这样的话就不需要等内存满时再触发内存回收。这样的好处是程序内存回收效率高，并且GC频率也会减少，程序的性能就提高了。
2. 同步消除。如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。
3. 分离对象或标量替换。
如果某个对象的访问方式不要求该对象是一个连续的内存结构，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。
简单来说就是把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。
这样的好处有，
1. 减少内存使用，因为不用生成对象头
2. 程序内存回收效率高，并且GC频率也会减少


https://www.cnblogs.com/death00/p/11722130.html
-------------------
方法内联
-------------------
-XX:PrintInlining
调用一个方法通常要经历压栈和出栈。调用方法是将程序执行顺序转移到存储该方法的内存地址，将方法的内容执行完后，再返回到执行该方法前的位置
这种执行操作要求在执行前保护现场并记忆执行的地址，执行后要恢复现场，并按原来保存的地址继续执行。 因此，方法调用会产生一定的时间和空间方面的开销(其实可以理解为一种上下文切换的精简版)
那么对于那些方法体代码不是很大，又频繁调用的方法来说，这个时间和空间的消耗会很大。
方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。


C++是否为内联函数由自己决定，Java由编译器决定。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字final修饰 用来指明那个函数是希望被JVM内联的


1. 经常执行的方法，默认情况下，方法体大小小于 325 字节的都会进行内联，我们可以通过-XX:MaxFreqInlineSize=N来设置大小值；
2. 不是经常执行的方法，默认情况下，方法大小小于 35 字节才会进行内联，我们也可以通过-XX:MaxInlineSize=N来重置大小值。

热点方法的优化可以有效提高系统性能，一般我们可以通过以下几种方式来提高方法内联：
1. 通过设置 JVM 参数来减小热点阈值或增加方法体阈值，以便更多的方法可以进行内联，但这种方法意味着需要占用更多地内存；
2. 在编程中，避免在一个方法中写大量代码，习惯使用小方法体；
3. 尽量使用 final、private、static 关键字修饰方法，编码方法因为继承，会需要额外的类型检查。

----------------
字段优化: 用JMH来测试
----------------

================
反射优化
================
public class Reflect1 {
   public static void foo() {
      System.out.println("foo...");
   }

   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
      Method foo = Demo3.class.getMethod("foo");
      for(int i = 0; i<=16; i++) {
         foo.invoke(null);
      }
   }
}

如果numInvocations > ReflectionFactory.inflationThreshold, 就会进行一个替换, 会从反射调用变为正常调用，即直接调用 Reflect1.foo()
把NativeMethodAccessorImpl替换成运行期间动态生成的新的方法访问器(动态生成的字节码)
膨胀阈值一般是15次, 可以修改的




