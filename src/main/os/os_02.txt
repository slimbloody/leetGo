==============================
第一章 操作系统的启动
==============================
1. 计算机怎么工作的:
白纸到图灵机:
人(图灵机) -> 笔(控制器) -> 纸(纸带)

从图灵机到通用图灵机:


    -----------------
    |   控制器       |
    |  ----------   |
    |  |修改控制器|   |---->------
    |  ----------   |          |
    |       ^       |          |
    |-------|-------|          | 处理(写入)
            |                  |
    -----------------          |
    |               |          |
------------------------------------
|设置控制器动作 | 控制器状态 |  数据对象 |  ------------->  纸带
------------------------------------
(就是应用程序去控制的)


冯诺依曼结构:
存储程序的主要思想:将程序和数据存放到计算机内部的存储器中，计算机在程序的控制下, 一步一步进行处理
输入输出设备 存储器 运算器 控制器

1. 把程序存在内存里, 把程序载入到cpu里进行解释执行, 输出结果

1. 把程序存在内存里
2. 用IP(PC)指针, 指向当前处理的指令
3. 把指向的指令载入进来形成控制逻辑(描述控制器的怎么工作的)
4. 解释执行指令
5. 用IP(PC)指针指向下一个指令
...
自动取指执行, 产生结果

计算机怎么工作的: 取指执行

--------------------------------------------------------------

开机发生了什么 == 开机pc指向的第一句语句/计算机执行的第一句指令 是什么
x86 PC: 有一部分内存是固化了的, (ROM BIOS) basic input output system


1.x86 PC刚开机时CPU处于实模式
和保护模式对应，实模式的寻址CS:IP(CS左移4位 + IP), 和保护模式不一样
2.开机时, (第一条指令的地址在用户按下计算机电源开关之后，CPU会自动的将其CS寄存器设定为0xFFFF，将其IP寄存器设定为0x0000,都是硬件自动设好的)CS=0xFFFF 段寄存器; IP=0x0000 偏移寄存器
3.寻址0xFFFF0(ROM BIOS映射区)
    地址计算: (CS << 4) + IP == OxFFFF0
    CS左移4位 + IP 刚好就是 0xFFFF0
4.检查RAM,键盘,显示器,软硬磁盘
    如果这一段过不去代表硬件坏了 不能运行操作系统
5.将磁盘0磁道0扇区读入0x7c00处
    一个扇区512字节, 0磁道0扇区就是操作系统的引导扇区, 操作系统中的第一个段代码读入进来
    // todo: 每次开机都要读0磁道0扇区, 这个地方是不是很容易坏道, 坏道了怎么办?
6.设置cs=0x07c0，ip=0x0000
    开始去引导扇区执行



=============================
0x07c0处存放的代码
=============================
--------------------------------------
为什么要用汇编代码:
如果用c去写, 编译以后可能产生一些控制不了的东西, 比如int i会出现在内存里面哪个位置?
汇编都是机器指令, 能精准控制
--------------------------------------

.text等是伪操作符，告诉编译器产生文本段，.text用于标识文本段的开始位置。此处的.text、.data、.bss表明这3个段重叠，不分段!

BOOTSEG = 0x07c0
INITSEG = 0x9000
SETUPSEG = 0x9020

此条语句就是0x7c00处存放的语句!

将0x07c0:0x0000处的256个字移动到0x9000:0x0000处
=============================
assembly language
=============================

BOOTSEG = 0x07c0
INITSEG = 0x9000
SETUPSEG = 0x9020

bootsect.s
.globl begtext,begdata,begbss,endtext,enddata,endbss
.text //文本段
begtext:
.data //数据段
begdata:
.bss //未初始化数据段
begbss:
entry start //关键字entry告诉链接器“程序入口”
start:
  mov ax, #BOOTSEG mov ds, ax // (源操作数在后面, 目标操作数在前面 ax <- #BOOTSEG, ds <- ax)
  mov ax, #INITSEG mov es, ax

----------------------
  mov cx, #256
  sub si, si sub di,di  // (两个值都为0 自己减自己 ds << 4 + si |  es << 4 + ds)
  rep movw
  // 移动256个字 正好是512个字节 为了腾出空间
  // mov之后的w代表在复制时的单位：字（word）
  // 从7C00 -> 90000
  // 将0x07c0:0x0000处的256个字移动到0x9000:0x0000处(为了腾出空间)
  // rep: 重复执行该语句直至寄存器cx为0
  // movw： 将DS: SI的内容送至ES: DI  note:是复制过去，原来的代码还在
  // 可以看出，我们并没有对si和di 的值进行修改，这是因为两者是可以自增的
----------------------

  jmpi go, INITSEG
  // jmp是跳转 jmpi是间接跳转
  // 为了把go给ip INITSEG给cs
  // cs和ip合在一起形成地址
  // cs的值是0x9000
  // ip的值是一个标号
  // go 会从start起始的地方, 经过了多少偏移

=============================

go: mov ax,cs //cs=0x9000
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, #0xff00
load_setup: //载入setup模块
  mov dx, #0x0000
  mov cx, #0x0002
  mov bx, #0x0200
  mov ax, #0x0200+SETUPLEN
  int 0x13
  // 执行"int n"时, CPU从中断向量表中, 找到第n号表项, 修改CS和IP
  // BIOS中断
  // 之前只是把操作系统的引导扇区读进来了, 操作系统后面还有很多内容没读完
  // 要用13号中断继续读进来
  // 从哪个扇区开始读: mov cx, #0x0002, CH: 柱面号: 0  CL: 开始扇区 2
  // 读取扇区的数量(AL: SETUPLEN: 4)
  // 四个扇区读到哪里: 一个扇区大小512, 4个扇区 512 * 4 => 90000(16进制) + 512*4()
  jnc ok_load_setup
  mov dx,#0x0000
  mov ax,#0x0000 //复位
  int 0x13
  j load_setup //重读

--------------------------------------

0x13是BIOS读磁盘扇区的中断:
AH=0x02-读磁盘
AL=扇区数量(SETUPLEN=4)
CH=柱面号
CL=开始扇区
DH=磁头号
DL=驱动器号
ES:BX=内存地址

--------------------------------------

Ok_load_setup: //载入setup模块
  mov dl,#0x00 mov ax,#0x0800 //ah=8获得磁盘参数
  int 0x13 mov ch,#0x00 mov sectors,cx
  mov ah,#0x03 xor bh,bh int 0x10 //读光标
  mov cx,#24 mov bx,#0x0007
  mov bp,#msg1 mov ax,#1301 int 0x10 //显示字符
  mov ax,#SYSSEG //SYSSEG=0x1000
  mov es,ax
  call read_it //读入system模块
  jmpi 0,SETUPSEG


read_it: mov ax,es cmp ax,#ENDSEG jb ok1_read
         ret

ok1_read:
         mov ax,sectors
         sub ax,sread //sread是当前磁道已读扇区数,ax未读扇区数
         call read_track //读磁道...

.org 510
         .word 0xAA55 //扇区的最后两个字节






=======================
段寄存器segment用来说明段的起始地址，有cs，ds，es，ss，任何CPU中长度都是16位。
cs段寄存器, code segment, 代码段起始地址
ds段寄存器, data segment, 数据段起始地址, 内存访问一般默认ds为段基地址
es段寄存器, extra segment, 附加段起始地址
ss段寄存器, stack segment, 堆栈段起始地址, bp, sp默认ss为段基地址
注意CPU工作在实模式下还是保护模式下，两个略有不同。

一个地址只有段寄存器不行, 要 段寄存器 + 段内偏移
=============================
AX――累加器（Accumulator），使用频度最高
BX――基址寄存器（Base Register），常存放存储器地址
CX――计数器（Count Register），常作为计数器
DX――数据寄存器（Data Register），存放数据
SI――源变址寄存器（Source Index），常保存存储单元地址
DI――目的变址寄存器（Destination Index），常保存存储单元地址
BP――基址指针寄存器（Base Pointer），表示堆栈区域中的基地址
SP――堆栈指针寄存器（Stack Pointer），指示堆栈区域的栈顶地址
IP――指令指针寄存器（Instruction Pointer），指示要执行指令所在存储单元的地址。IP寄存器是一个专用寄存器。
=============================
最早8位机只有A, B等寄存器。

到16位机A, B扩展到16位以后，就把16位叫AX, BX. 高8位叫AH, BH, 低8位叫AL, BL，其实还是A, B

到了32位机A, B扩展到32位, 又改成EAX, EBX
当然AX, BX继续代表低16位, AH, AL, BH, BL, A, B继续维持以前的意义不变。
如何取高16位: bitwise
=============================

引导扇区就是启动设备的第一个扇区
启动设备信息被设置在CMOS中
[Complementary Metal Oxide Semiconductor（互补金属氧化物半导体）]
CMOS常指保存计算机基本启动信息（时钟,启动设置,硬件配置信息）的芯片

引导扇区坏了怎么办
1、如果硬盘引导扇区损坏，需要打开分区助手功能进行修复。方法就是用硬盘医生检查坏道和分区，并且格式化以后，可以自动修复。修复就是把坏扇区隐藏起来，这样重新格式化，重写引导记录，这样硬盘就算修复了。
2、如果损坏严重，最好把硬盘低格一下，然后重新分区，就会把坏扇区彻底修复。不过这种方法会伤害硬盘，将会降低硬盘寿命。轻易不要选择此方法。
=======================

1.并发高挡住并发
2.占用进程中的内存
