=====================
Ordering of messages
=====================
let's say reliable network links the messages might be delayed or might be reordered as usual.


attach timestamp to each message by using local clock generating timestamp



Problem: even with synced clocks, t2 < t1 is possible.
Timestamp order is inconsistent with expected order!

we're going to assume that these are of course physical time of day clocks, we're going to assume that the clocks are synchronized using something like ntp
but it could still happened even if clocks are synchronized, it can happen that the timestamp t2 is actually less than the timestamp t1. this could happen because the clock skew between two nodes in a system might be greater than the one-way network delay between those two nodes, and even with ntp synchronization we cannot rule out the possibility that the clock skew is greater than the one-way network latency.


so our whole aim of this exercise was to ensure that messages get put in the right order, according to time, but even using time here we have not actually been able to put the messages in the right order, because the timestamp order is inconsistent with our understanding of which message is a reply to which other message.


===========================
The happens-before relation
===========================
An event is something happening at one node (sending or receiving a message, or a local execution step).

the things that happen are events, an event can be just one node in the system making a local execution step, one node doing something that can be an event,
or an event could be a message that one node sends to another, so the sending of the message is one event, and then the receiving of the message is another event, if the message arrives, then receiving would be another event,

We say event a happens before event b (written a -> b) iff:

so now we can define a relation which is a set of pairs of events that describes how those events relate to each other, and this happens before relationship is written as a A arrow B, if a happened before b, we say that a happened before b, if at least three things are true:
1. a and b occurred at the same node, and a occurred before b in that node's local execution order; or
we assume that each node is a single threaded process that is just doing one thing after another, so there's no ambiguity about the order in which things happened on a single node, if there's a single thread, then things only happen one after another and we can define exactly which thing happened first and which happened second. so we're going to assume that for each node, there's a strict total order of all of the events that happened on that particular node, if we did wanted to support multi-thread processes, then we could have each thread being a separate node for the purposes of this model here. so we can just assume single threads for now. and so we're going to say that a happened before b is they happened on the same node, and they were executed, a was executed before b, that makes sense

2. event a is the sending of some message m, and event b is the receipt of that same message m (assuming sent messages are unique); or
otherwise you could have two different events for the sending of the sme message, which of course could happen in a real system, but it makes the thing difficult to model mathematically, so for simplicity's sake here, we just assume that every message that is sent is unique, and if we wanted to actually make messages unique in practice, we could attach some kind of sequence number and the identifier of the node that sent the message for example we could attach that to every message, or we could pick a long random number for every message and that would be sufficient to make every message unique. and so this happens before relationship make sense because a message can only be received after it has been sent, and so it makes sense for the sending of that particular message to the happen-before receipt of that message.

3. there exists an event c such that a> c and c> b.
if we can find some event c such that a happened before c, and c happened before b, then it must also be the case that a happened before b, so this is simply taking the transitive closure of the first two points and extending the whole thing into what is called a partial order, so a partial order is it behaves a bit like a less than relationship between two things. so it allows you to compare two things, and say which one happened first, but there might be something incomparable according to this order where we simply it is not the case that a happened before b or b happened before a, the two are simply unrelated, it is not the case that either one happened before the other, and in that case we say that a and b are concurrent, and we write it with this little double bar(the parallel sign) here.


The happens-before relation is a partial order: it is possible
that neither a -> b nor b -> a. In that case, a and b are concurrent (written a || b).

todo: the exercise to prove these three possibilities.

========================================
Happens-before relation example
========================================
we're going to build up the happens before relationship from the individual clauses

1. a -> b, c -> d, and e -> f, due to process order
2. b -> c, d -> f, due to messages m1 and m2
3. a -> c, a -> d, a -> f, b -> d, b -> f, c -> f, due to transitivity


message m1/m2 traveling over the network.
so now we've got all of these relationships between some of the events. now we extend this whole thing with the transitive closure. essentially what you can imagine here, is we can take a path through this graph, you can imagine any path that moves forward in time on a node, or that moves from the sending of a message to the receipt of the message. and then moves through other nodes, you can take any path through this graph as long as you're always moving forward in time, then you will get from any a that happened before any other event

4. a || e, b || e,  c || e, adn d || e
concurrent does not literally mean simultaneous, it doesn't mean happened literally at the same instant in time, it just means the two events did not know about each other when they occurred.
therefore, A is concurrent with E, b is concurrent with all a b c and d, they're all concurrent to e, but e and f are not concurrent of course, because of the order on USER C



that happens before relation is very closely connected to the concept of causality in distributed systems.
in particular, if a happened before b, then it might be the case that a caused b or a influenced b in some way. so there's some information flow, that has happened from a to b, whereas if the events a and b are concurrent, we know that a cannot have caused b and b cannot have caused A. there's no causal relationship between the two, so this concept of causality is actually taken from physics where typically people reason about events that happen far apart in space. and the time that is takes the speed of light to travel between those things.



=================
Causality
=================
Taken from physics (relativity).
    1. When a -> b, then a might have caused b.
    2. When a || b, we know that a cannot have caused b.
Happens-before relation encodes potential causality.



≺	8826	227A	 	PRECEDES
≻	8827	227B	 	SUCCEEDS
Let ≺ be a strict total order on events.
If(a→b) ==> (a < b) then ≺ is a causal order
(or: ≺ is "" consistent with causality")

NB注意，留心（拉丁语 nota bene，用于书面注意事项）
NB. causal != casual

causal order:
it's a way of putting the events in the system into an order in such a way that they are consistent with causality, that if one thing happened before another thing, then they appeared in correct order, but if two things are concurrent then they could appear in either order. because one could have happened before the other there's no real way of saying which one happened first, so in that case, they could be ordered arbitrarily.
















