so we've talked about these eventually consistent systems, for the last section, let's switch back to very strongly consistent systems,

=====================================
Google's Spanner
=====================================
A database system with millions of nodes, petabytes of data, distributed across datacenters worldwide(spread all around the globe) (despite this huge scale, we want to achieve very strong consistency properties in this database)


Consistency properties:
    1. Serializable: transaction isolation(strongest isolation we can get)
    2. Linearizable: reads and writes(we're always going to see an up-to-date value from any value written)
    3. Many shards, each holding a subset of the data; atomic commit of transactions across shards

we need to support sharding which means that this huge amount of data which is far too much to store on a single node, we have to split into subsets of data of each node has a replica of a subset of the data, so that now you can distribute the data across all of these different nodes, but this now means that you might have a transaction needs to read and write on multiple nodes, and if this happens, distribute a transaction like this, we need atomic commit so that any changes made by a transaction will either be committed on all of the nodes or aborted on all of nodes. so all of these classic properties we want and a lot of the techniques that Spanner uses to implement these properties are equally classic standard algorithms.
in order to replicate the nodes within a shard it uses state machine replication, it uses the Paxos consensus algorithm rather than raft, but they are reasonably similar and the principle are very much the same.
in order to achieve serializable transaction isolation, we use the classic two-phase locking that means for any reads we take a shared lock on any data we want to read, and for any writes, we'd need to take an exclusive lock on any data that we write and we need to hold those locks until the transaction commits.
Finally in order to achieve atomicity across multiple shards, we do the classic, we do two-phase commit exactly like we saw in the last lecture.


The interesting bit: read-only transactions require no locks!
two-phase locking means that if you want to read any data you first have to take a shared lock on that data under shared lock is going to prevent any other transactions from updating that data, but now in real systems, you often get very large read-only transactions, so for example taking a database backup is a very large read-only transaction, that needs to read essentially the entire database, that's what a backup i8s, it's a copy of the entire database. and so this backup may take a long time, and if you have to take a shared lock on the entire database for a long time while you're doing a database backup.