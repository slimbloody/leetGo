In this section, I'm going to walk you through the entire raft consensus algorithm for performing total order broadcast
what I would like you to do though, is to carefully understand exactly how and why the algorithm works, because I find that principle of how the raft algorithm works are really instructive for thinking about state in a distributed system more generally.
=======================================================
Node state transitions in Raft
=======================================================
the core of the raft algorithm is a state machine where every node can be in what in one of three states either a follower, a candidate, or a leader.
and the state is always in a certain term, so there's always a certain term number, and a node can be deleted in a particular term.

when a node starts up for the first time, it always goes into the follow-up state, and also if a node crashes and recovers and then when the nodes restarts and recovers from the crash, it always goes back into the follower state regardless of which state it was in before the crash.

however all of the nodes start as followers eventually we need some node become the leader, and the way how a node becomes the leader is by first becoming a candidate. and so when a node detects that there has been no message from a leader for some amount of time, a timeout elapses, and then a node will decide that okay it is going to stand as candidate in a particular term number, and it's within that term number, it's going to get votes from the other nodes. and it manages to get positive votes from a quorum of nodes in the system from majority, then it is able to transition into the leader state

however it could also happen that in the process of this election, the candidate discovers that there's a different node with a higher term number, and if it does so, then the candidate immediately steps back becomes follower again, and works with the node that has the higher term number, so a higher term number always take precedence.

it could also happen while a node in candidate state, it's doing the election, but maybe it's not able to communicate with a quorum of replicas right now, or quorum of nodes, and so it times out, so it simply doesn't receive a quorum of positive votes within the required time, and if so it will restart its election again with a higher term number, so it remains candidate and starts again with a higher term number.

likewise it could happen if the leader is just doing its leadering job, it might discover that there's a node with a higher term number, perhaps the system has been partitioned, so that some subset of nodes have elected with a new leader with a a higher term number in the meantime, and if so the leader will always step back and become a follower again immediately upon discovering some other node with a higher term number. so we always have a peaceful transition of power in the raft algorithm from the lower term number to the higher term number.

### todo: 如果这个时候step back, 那么之前这个节点走过的路径是不是要回退?重新走新节点走过的路径


so let's run through the actual code
========================================
Raft (1/9): initialisation
========================================
so here we start off with usual initialization of variables, I'm not going to explain every single variable right now, but i will explain the variables as we use them as part of the algorithm.
--------------------------------------------------------------
on initialisation do
    currentTerm := 0; votedFor := null
    log := <>; commitLength := 0
    currentRole := follower; currentLeader := null
    votesReceived := {}; sentLength := <); ack:edLength := <>
end on
-------------------------------------------------

-------------------------------------------------
on recovery from crash do
    currentRole := follower; currentLeader := null
    votesReceived := {}; sentLength := <>; ackedLength := <>
end on
-----------------------------------------------------
but I will just point out here the first four variables,

currentTerm, votedFor, log and commitLength

these four variables have to be stored in stable storage that is on disk, whereas the remaining five variables they can be in transient storage that they can be lost in the case of a crash. but the first four variable have to be preserved in the case of a crash, and you can see the crash recovery here, so the five remaining variables simply get reset to new fresh state if we recover from a crash

-----------------------------------------------------
on node nodeId suspects leader has failed, or on election timeout do
    currentTerm := currentTerm + 1; currentRole := candidate
    votedFor := nodeId; votesReceived := {nodeId}; lastTerm := 0
    if log.length > 0 then lastTerm := log[log.length - 1].term; end if
    msg := (VoteRequest, nodeId, currentTerm, log.length, lastTerm)
    for each node∈nodes: send msg to node
    start election timer
end on
-----------------------------------------------------
when a node suspects that the leader has failed, it will become a candidate and it will start an election, that's what happens here, by the way, typically this timeout that the node uses before it suspects a leader to have failed is ###randomized###, and the purpose for that is to avoid having lots of nodes all trying to become candidate at the same time which is what would happen if all the nodes start up at the same time, and then have the same timeout before they start an election, so randomizing the timeout reduces the probability of having several elections at the same time.

so whenever that happens now so the node decides it's time to start an election,

-----------------------------------------------------
    currentTerm := currentTerm + 1; currentRole := candidate
-----------------------------------------------------
it increments the current term, it sets its current role to be the candidates state,

-----------------------------------------------------
    votedFor := nodeId;
-----------------------------------------------------
and like in every good election everyone votes for themselves in an election, also in raft, so the node that has just become a candidate votes for itself by setting this "votedFor" variable to its own node id,

-----------------------------------------------------
    votesReceived := {nodeId};
-----------------------------------------------------
and it has this set of node ids in which records the set of votes that it has received in favor of itself as a candidate, and it puts its own node id as the first member of that set of votes received.

-----------------------------------------------------
    lastTerm := 0
    if log.length > 0 then lastTerm := log[log.length - 1].term; end if
-----------------------------------------------------
this variable "lastTerm" is initially zero, but you can see if the length of the log is greater than zero, then we set this last term variable, so let me explain first what the log is.



============================================================
        ┌──┐   ┌──┐   ┌──┐
        │m1│   │m1│   │m1│◄────msg
  log = ├──┤   ├──┤   ├──┤
        │1 │   │1 │   │1 │◄────term
        └──┘   └──┘   └──┘
         ▲      ▲      ▲
         │      │      │
     log[0] log[1] log[2]
============================================================
so the log you can see illustrated up here is an array, or a list, it's a sequence of log entries, each log entry consists of two parts.
firstly a message, so this is the message that we want to deliver via total order broadcast, that's the whole thing that the purpose of the algorithm.
and secondly a term number on every log entry, so this term number is the term number of the leader at the time when that leader added that particular entry to the log, we'll see later why that term number is important, but for now just accept that log is this structure here. it's in there in zero indexed array where log0 is the first log entry.

-------------------------------
    if log.length > 0 then lastTerm := log[log.length - 1].term; end if
-------------------------------
and log.length is the number of log entries in the log, and if the log is non-empty here, if the log.length greater than zero, than we're going to say that the last term is the term field of the last log entry, so log.length minus one is the index of the last entry in the log, and so we take the term field of that last log entry, and set that to be the value of this variable "lastTerm".

-------------------------------
    msg := (VoteRequest, nodeId, currentTerm, log.length, lastTerm)
-------------------------------
and we then construct a message that will be sent to all of the nodes, and so the candidate sends the same message to all of the nodes.

VoteRequest:
it's a message tagged with the message type "VoteRequest", saying "please vote for me"
and the message contains the several fields,

nodeId:
it contains the node id of the candidate,

currentTerm:
it contains the current term after that term number has been incremented,

log.length:
it contains the length of the log on candidate

lastTerm:
and it contains this lastTerm variable which as I just said is the term field of the last log entry in the candidates log.

-------------------------------
    for each node∈nodes: send msg to node
    start election timer
-------------------------------
it sends this same message to all of the nodes, and it starts the timer that might eventually timeout if it doesn't manage to do the election successfully



so that's the candidate, let's see what happens on the other nodes that receive one of these wrote request messages
==============================
Raft (2/9): voting on a new leader
==============================
note: c for candidate

on receiving (VoteRequest, cId, cTerm, cLogLength, cLog Term) at node nodeId do
    if cTerm > currentTerm then
        currentTerm := cTerm; currentRole := follower
        votedFor := null
    end if
    lastTerm := 0
    if log.length > 0 then lastTerm := log log.[length - 1].term; end if
    logOk := (cLogTerm > lastTerm) ∨
             (cLogTerm = lastTerm ∧ cLogLength >= log.length)

    іf сТеrm = сurrеntТеrm ∧ lоgОk ∧ vоtеdFоr ∈ [ сІd, null] thеn
        votedFor := cId
        send(VoteResponse, nodeId, currentTerm, true) to node cId
    else
        send(VoteResponse, nodeId, currentTerm, false) to node cId
    end if
end on
---------------------------------------------------------------------------------------
so now we're one of the other nodes that has received a message from the candidate, and we have the id of the candidate(cId), we have the term number of the candidate(cTerm), the length of the candidate's log(cLogLength), and the term number in candidates last log entry(cLogTerm),


-------------------------------------------
    if cTerm > currentTerm then
-------------------------------------------
and first thing we're going to do when receiving a vote request message is to compare the candidate term to the current term of the recipient of this message, and if the candidate's term is greater than the current term of the recipient,

-------------------------------------------
        currentTerm := cTerm; currentRole := follower
-------------------------------------------
then we move forward and join then term of the candidate, so we do that by setting the recipient's current term to be the candidates term to transition into the follower state regardless of what the node's previous state was,

-------------------------------------------
        votedFor := null
-------------------------------------------
and this voted for variable gets set to null which mean that we have not yet voted for any candidate in the current term because we just change the current term. however, we might vote for that candidate in a minute.


-------------------------------------------
    lastTerm := 0
    if log.length > 0 then lastTerm := log log.[length - 1].term; end if
-------------------------------------------
so next, we set up this variable lastTerm, very similar to the way we did on the candidate, and that is we look at the last log entry on the recipient of this vote request message, we get the term number in that last log entry, and we set that to be this lastTerm variable.




now what we need to do is to check if the candidates log is up to date with our own log, the reason for that is that we don't want a candidate with an outdated log become the leader, and exactly what outdated means will become apparent later, but it's crucial that we want the candidates log to reflect all the updates that at least the quorum of the other nodes have seen, so you don't end up with a leader whose log is really outdated, because that might lead to the loss of some messages.
### todo: 既然已经有cTerm了, 为什么需要cLogTerm来确认, 大家看到的Message(xxx)都是一样的

-------------------------------------------
    logOk := (cLogTerm > lastTerm) ∨
             (cLogTerm = lastTerm ∧ cLogLength >= log.length)
-------------------------------------------
so we have this "logOk" variable here which will contain a boolean which tell us whether the current node thinks the candidate's log is okay to vote in favor of, and so there are two criteria here,

-------------------------------------------
    logOk := (cLogTerm > lastTerm) ∨
-------------------------------------------
first of all, if the logTerm of the candidate, so the term number that appears in the last log entry of the candidate, if that term number is greater than the term number of the log entry on the recipient of this vote request message, then we consider the log to be okay.

 V: for or
-------------------------------------------
             (cLogTerm == lastTerm ∧ cLogLength >= log.length)
-------------------------------------------
secondly anther way for the log to be okay is for the log terms in the last log entry to be the same, but for the candidates to have a log that is at least as long as the log of the recipient of this vote request message.
### todo: 为什么任期相同的candidate的log要大于等于现有的长度?



so one of those things needs to be true either or, and if so then the log is okay.



-------------------------------------------
    іf сТеrm = сurrеntТеrm ∧ lоgОk ∧ vоtеdFоr ∈ [сІd, null] thеn
        votedFor := cId
        send(VoteResponse, nodeId, currentTerm, true) to node cId
    else
        send(VoteResponse, nodeId, currentTerm, false) to node cId
    end if
-------------------------------------------
so we will now vote for this candidate if three criteria will hold.

-------------------------------------------
сТеrm = сurrеntТеrm:
-------------------------------------------
firstly if the candidate's term equals the current term, that is it's not in some outdated term, we haven't seen any other node with a higher term number,

-------------------------------------------
lоgОk
-------------------------------------------
secondly if the candidates' log is okay,

-------------------------------------------
vоtеdFоr ∈ [сІd, null]
-------------------------------------------
and thirdly if we have not yet voted for any other candidate in the current term , so this voted for variable would be null if we have not yet voted at all for any candidate in the current term, or it could be cid if we've already voted for the same candidate, it's okay to vote several times for the same candidate in a single term, but we must not vote for two different candidates within the same term.

-------------------------------------------
        votedFor := cId
-------------------------------------------
so if all those three criteria are true, then we can vote in favor of this candidate, we will do that by first setting our voted four variable to cid to remember the fact that we have voted for the candidate.


-------------------------------------------
        send(VoteResponse, nodeId, currentTerm, true) to node cId
-------------------------------------------
 and then we send a vote response message back to the candidate and this is going to contain node id of the node doing the vote. it's going to contain the current term number so we know which term this election is for, and the value true to indicate that it's a vote approval in favor of this candidate,

on the other hand if any of those things are not true, then we send a vote response with a false field back to the candidate, telling it that we are not voting in favor of this candidate.



now we move back to the candidates, and we aggregate we collect the votes that we receive.
so any time we receive a vote response message, this is what happens.
==========================================
Raft (3/9): collecting votes
==========================================
on receiving (VoteResponse, voterId, term, granted) at nodeId do
    if currentRole == candidate ∧ term == currentTerm ∧ granted then
        votesReceived := votesReceived ∪ {voterId}
        if votesReceived| ≥「(|nodes|+ 1)/2] then
            currentRole := leader; currentLeader := nodeId
            cancel election timer
            for each follower∈nodes \ {nodeId} do
                sentLength[follower] := log.length
                ackedLength[follower] := 0
                REPLICATELOG(nodeId, follower)
            end for
        end if
    else if term > currentTerm then
        currentTerm := term
        currentRole := follower
        votedFor := null
        cancel election timer
    end if
end on
------------------------------------------------------------------------

------------------------------------------------------------------------
on receiving (VoteResponse, voterId, term, granted) at nodeId do
------------------------------------------------------------------------
so we have a VoteResponse("VoteResponse") with the id of the node("voterId") that is voting, with the term number("term") in which the vote is happening, and with the boolean("granted") telling us whether that vote is granted or not.

and the first thing we do is to check the term number
------------------------------------------------------------------------
    else if term > currentTerm then
------------------------------------------------------------------------
so if the term number in the VoteResponse message is greater than our "currentTerm", we do the usual thing,

------------------------------------------------------------------------
        currentTerm := term
------------------------------------------------------------------------
we accept that term number as our own

------------------------------------------------------------------------
        currentRole := follower
------------------------------------------------------------------------
we transition into follower state

------------------------------------------------------------------------
        votedFor := null
------------------------------------------------------------------------
we forget which node we voted for in some previous term

------------------------------------------------------------------------
        cancel election timer
------------------------------------------------------------------------
and we cancel any election timer.


###
todo: 执行完这波操作以后, 又回到头部开始重新做判断了? 这里是不是要 把 else 改成 if 放到前面好一点?
todo: 刚开始那段if往下移动
###
so just moves us back into the follow state in the state machine.

------------------------------------------------------------------------
    if currentRole == candidate ∧ term = currentTerm ∧ granted then
------------------------------------------------------------------------
however, if we are still in the candidate state, and the if the message that we just received is for the correct term that in which we're performing the election, and the "granted" field is true. then we have a vote in favor of us as the candidate

------------------------------------------------------------------------
        votesReceived := votesReceived ∪ {voterId}
------------------------------------------------------------------------
so we're going to maintain this set of "votesReceived" here, and we're going to add the id of the voter("voterId") to the set of votes we received, notice that this update here is idempotent, so even if this vote response message gets duplicated in the network somewhere, that's not a problem, we're not going to count the same vote more than once, we still require votes from a quorum of different nodes.


------------------------------------------------------------------------
        if |votesReceived| ≥「(|nodes|+ 1)/2] then
------------------------------------------------------------------------
so then to determine whether we have a quorum yet, we can check the cardinality of this set "votesReceived", and if the number of votes we received("|votesReceived|") is greater than or equal to a majority that is the number of nodes("(|nodes|+ 1)/2") in the system plus one divided by two round upwards, then we have a majority quorum of nodes and at that point we can become the leader.

------------------------------------------------------------------------
            currentRole := leader; currentLeader := nodeId
            cancel election timer
------------------------------------------------------------------------
so we transition into leader state, the currentLeader well that's ourselves.
now we can cancel the election timer as well.



------------------------------------------------------------------------
            for each follower∈nodes \ { nodeId} do
                sentLength[follower] := log.length
                ackedLength[follower] := 0
                REPLICATELOG(nodeId, follower)
            end for
------------------------------------------------------------------------
------------------------------------------------------------------------
            for each follower∈nodes \ { nodeId} do
------------------------------------------------------------------------
now we need to send a message to all of the nodes which are now the followers to tell them, "hey, I'm your new leader", and give it a bit of information.

------------------------------------------------------------------------
                REPLICATELOG(nodeId, follower)
------------------------------------------------------------------------
so this replicate log function here is going to do the actual sending of that message, and we will see that function in a minute,

------------------------------------------------------------------------
                sentLength[follower] := log.length
                ackedLength[follower] := 0
------------------------------------------------------------------------
we also need to set up for all of the followers some variables, these variables here "sentLength" and "ackedLength" are maps from nodeId to an Integer.
and so for each of the follower nodes, we're going to initialize these variables here. the sentLength is going to be initialized with the length of the log on the leader, and the meaning of sentLength is the number of log records that we have already sent to a particular node. so here we are assuming that the follower has already received all of the log entries from us. if that is not the case, we will correct that later through a process that we will see later.
secondly actLength is the number of log entries counted from the beginning, that this particular followers acknowledged as having received. and we initialized that to be zero, and later as we receive acknowledgements, we will increase that number.

okay so that's all we have to do to become a leader.



==========================================
Raft (4/9): broadcasting messages
==========================================
now that we have a leader, we can actually start talking about the total order broadcast.

------------------------------------------
on request to broadcast msg at node nodeId do
    if currentRole = leader then
        append the record (msg : msg, term : currentTerm) to log
        ackedLength[nodeId] := log.length
        for each follower ∈nodes \ {nodeId} do
            REPLICATELOG(nodeId, follower)
        end for
    else
        forward the request to currentLeader via a FIFO link
    end if
end on
------------------------------------------

------------------------------------------
on request to broadcast msg at node nodeId do
------------------------------------------
so what we have here is now a function that can be called by a client for example, to say okay we want to broadcast a message, and we want to do that via total order broadcast ensuring that all nodes delivered that the messages in the same order.
now the order in which those messages are going to be delivered is in fact exactly the log, that's the whole purpose of the log, and the only node that can add entries to the log is the leader.


------------------------------------------
    else
        forward the request to currentLeader via a FIFO link
    end if
------------------------------------------
and so first of all, the first thing we have to do is if the request to broadcast a message happens not on the leader, then it has to be forwarded to the current leader via a FIFO link, using a FIFO link here just ensures that in total, we actually get FIFO total order broadcast, not just total order broadcast, and that's the only thing we need to do in order to ensure the FIFO aspect.

------------------------------------------
    if
        currentRole = leader then
------------------------------------------
if the current node is the leader, and we may have just received one of those forwarded requests to broadcast a message.

------------------------------------------
        append the record (msg : msg, term : currentTerm) to log
------------------------------------------
well the first thing we do is we append a record to the log, containing the message that we want to broadcast, and containing the "currentTerm" number of the leader.

------------------------------------------
        ackedLength[nodeId] := log.length
------------------------------------------
we also note that the leader itself has acknowledged the delivery of this message, and that's just another instance of voting for ourselves, so node id here is the id of the leader, and so we're just updating this "ackedLength" variable, to include the newly appended record.


------------------------------------------
        for each follower ∈nodes \ {nodeId} do
            REPLICATELOG(nodeId, follower)
        end for
------------------------------------------
and now we call again this replicate log function that we already had on the last slide, for each of the followers so all of the nodes in the system apart from the leader.



------------------------------------------
periodically at node nodeId do
    if currentRole = leader then
        for each follower ∈nodes \ {nodeId} do
            REPLICATELOG( nodeId, follower)
        end for
    end if
end do
------------------------------------------
moreover, we also call this replicated log function periodically, so the leader even if it doesn't have any new messages appended to the log lately, it's still called replicate log for each of the followers periodically.
and that has several purposes,
one is to act as a kind of heartbeat, so it's calling replicate log sends a message to the followers just telling them that the leader is still alive, so they don't need to start a new leader election, everything is fine.
this calling replicate log also ensures that if any messages got lost for example, they will get redelivered, and it ensures that if the leader has committed any log entries, then they will also be committed on the followers, process for committing we will see later.



so let's have a look at this replicate log function that we've just seen called three times
==========================================
Raft (5/9): replicating from leader to followers
==========================================

Called on the leader whenever there is a new message in the log, and also periodically. If there are no new messages, suffix is the empty list. LogRequest messages with suffix = <> serve as heartbeats, letting followers know that the leader is still alive.
------------------------------------------
function REPLICATELOG(leaderId, followerId)
    prefixLen := sentLength[followerId]
    suffix := <log[prefixLen], log[prefixLen + 1], ..., log[log.length - 1]>
    prefixTerm := 0
    if prefixLen > 0 then
        prefixTerm := log[prefixLen - 1].term
    end if

    send (LogRequest, leaderId, current Term, prefixLen,
          prefixTerm, commitLength, suffix) to followerId
end function
------------------------------------------

------------------------------------------
function REPLICATELOG(leaderId, followerId)
------------------------------------------
so this replicate log function gets called first of all with the node id of the leader("leaderId") and node id of the follower("followerId"), and we have access to all of the variables from before.

------------------------------------------
    prefixLen := sentLength[followerId]
------------------------------------------
so first of all, we are going to now split the log on the leader into a prefix and a suffix, the prefix will contain all of the log entries that we think we have already sent to the follower.

------------------------------------------
    suffix := <log[prefixLen], log[prefixLen + 1], ..., log[log.length - 1]>
------------------------------------------
and the suffix will contain all of the new log entries that we think we have not yet sent to this particular follower, and so we have this variable sent length here which records for every node id, the number of log entries, that we think we have already sent there, and so this prefix length is just an integer now,
and I'm going to take the suffix of the log which is starting at the index prefix length and going all the way up to the end of the log, so all of the remaining log entries after prefix length, it could happen that prefix length is indeed the length of the entire log in which case the suffix would just be an empty array.

next we set up this variable term, the prefix term and that is now going to be looking at the log entries, we're going to look at the last log entry within the prefix, and look at the term number of that log entry, so this is a bit similar to what we had previously in the vote request message, in this case, what we're looking at is not the last entry in the log all together but the last log entry in the prefix, and getting the term number of that, and we're now going to send a log request with all of these various variables to the follower, so in this message, we're going to include the id of the leader, the term number in which it's the leader, the length of the prefix that we are not sending, the term number of the last log entry in the prefix, the commitLength which is a variable that we will see later that's just another integer, and then suffix which is this array of new log entries that we want to add to the log.


okay, so that was how we send the log request.

now we're on the followers, and we will see how to receive one of these log request messages.
==========================================
Raft (6/9): followers receiving messages
==========================================
on receiving (LogRequest, leaderId, term, prefixLen, prefixTerm,
              leaderCommit, suffix) at node nodeId do
    if term > currentTerm then
        currentTerm := term; votedFor := null
        cancel election timer
    end if

    if term == currentTerm then
        currentRole := follower; currentLeader := leaderId
    end if

    logOk := (log.length ≥ prefixLen) ∧
             (prefixLen == 0 ∨ log[prefixLen - 1].term = prefixTerm)

    if term = currentTerm ∧ logOk then
        APPENDENTRIES(prefixLen, leaderCommit, suffix)
        ack := prefixLen + suffix.length
        send (LogResponse, nodeId, currentTerm, ack, true) to leaderId
    else
        send (LogResponse, nodeId, currentTerm, 0, false) to leaderId
    end if
end on
------------------------------------------

------------------------------------------
on receiving (LogRequest, leaderId, term, prefixLen, prefixTerm,
              leaderCommit, suffix) at node nodeId do
------------------------------------------
so we've got all of the variables that i just mentioned

------------------------------------------
    if term > currentTerm then
------------------------------------------
and first thing we need to do as always is to check the "term" number, and so if the term("term") number in the message is greater than the term number on the follower(currentTerm),

------------------------------------------
        currentTerm := term; votedFor := null
        cancel election timer
------------------------------------------
then we're going to do the usual state machine thing, we're going to accept the currentTerm, we're going to forget what candidate we voted for.
in the previous term I'm going to cancel election timer.

------------------------------------------
    if term == currentTerm then
        currentRole := follower; currentLeader := leaderId
    end if
------------------------------------------
and we will also fall through to this second if condition where we set the current role to be follower. and we accept the current leader as being the sender of this log request message.

so we fall through to this second case, because here(第三段) we update currentTerm to equals term, and so it still equals currentTerm here, in the second condition. the second condition also here because it could happen that the node receiving the log request is actually a candidate in the same term number as the leader. and in that case, we also want to move into follower state, even though we're not changing the term number, but we still want to accept the leader as at the center of this log request message as the leader.

------------------------------------------
    logOk := (log.length ≥ prefixLen) ∧
             (prefixLen == 0 ∨ log[prefixLen - 1].term == prefixTerm)
------------------------------------------
okay, next thing we need to do is do another check if the log is okay, this is a bit similar to what happened earlier during the leader election, but the condition is a little different.

so here what we first of all want to ensure is remember we said on previous slide, we split the log into a prefix that we are not sending which we assume the recipient already has, and suffix which contains the new log entries.
well first of all, we have to check that prefix we actually do have as the sender of the message thought we might do.

------------------------------------------
    logOk := (log.length ≥ prefixLen) ∧
------------------------------------------
so first of all, we have to check that the followers length of the log("log.length"), is at least as long as ("prefixLen")the prefix that we left out on the sender, so if this is not the case that means there would be a gap in the log, where there's some log entries that the leader didn't send us but we also don't have a follower, and so in that case the log would not be okay we have to fill in that gap first.

------------------------------------------
             (prefixLen == 0 ∨ log[prefixLen - 1].term == prefixTerm)
------------------------------------------
the second requirement is either the length of the prefix is zero, or, if the prefix is not zero then we have to look at the last log entry in the prefix on the follower, look at its term number, and we want that term number to be equal to the corresponding log entries term number on the leader, this prefix term is just a variable that was sent as part of the message.
so the purpose for this is raft has a certain invariant that it guarantees, and that is if there are two nodes in the system that have a certain log and that's at a certain index of the log they have the same log entry, in particular they have the same term number in that log entry, then raft will guarantee that the entire log up to and including that index will be identical, so the term number in the log entries actually allows us to tell efficiently whether two nodes have the same log or not because the only way that two nodes could end up with different logs is by having different term numbers on a certain log entry, so what this here now guarantees is that if this log okay condition is true, that means that the prefix of the log as it was on the leader is identical to the prefix of the log of the same length as it is on the follower.

so this log okay condition checks that actually the up to that point the logs are identical this is absolutely crucial for ensuring that actually all of the nodes end pu with the same messages delivered.


------------------------------------------------------------------------------
    if term = currentTerm ∧ logOk then
------------------------------------------------------------------------------
now if this log is okay, and if the message was for the correct term, then we can go ahead and process the new log entries that were in this log request message,

------------------------------------------------------------------------------
        APPENDENTRIES(prefixLen, leaderCommit, suffix)
------------------------------------------------------------------------------
 and the way we're going to do this is we're going to call the append entries function that I will show you in a minute, and we are going to pass it the suffix, the new log entries, and a few other variables,

------------------------------------------------------------------------------
        ack := prefixLen + suffix.length
        send (LogResponse, nodeId, currentTerm, ack, true) to leaderId
------------------------------------------------------------------------------
and we're going to also send an acknowledgement back to the leader, saying hey we received your log entries, it's all fine, and this acknowledgement is going to be just another integer, and it's going to be the integers telling how many log entries from the start of the log that we have successfully received from the leader. and that is going to be the length of the prefix that was not sent plus ("suffix.length"){the number of log entries in the suffix} that was sent, so that's the total number of log entries that we have from the leader after processing this message. this "ack" integer, we're just going to pack into a message, so we're going to make a log response message that we sent back to the leader, it's going to contain the id of the sender of the log message, the current term number as always, the act that I just explained and true to indicate that this was successful so the follow was successfully able to process this log request message.


------------------------------------------------------------------------------
    else
        send (LogResponse, nodeId, currentTerm, 0, false) to leaderId
    end if
------------------------------------------------------------------------------
on the other hand, if something is not okay, so if the term number is wrong, or if the log okay is false, then we send back a log response message in which the last element is false. and that tells the leader that we were not able to process that log request message correctly.






=============================================
Raft (7/9): updating followers' logs
=============================================
let's look at this append entries function that I just mentioned.

------------------------------------------------------------------------------
function APPENDENTRIES(pefixLen, leaderCommit, suffix)
    if suffix.length> 0 ∧ log.length > prefixLen then
        index := min(log.length, prefixLen + suffix.length) - 1
        if log[index].term ≠ suffix[index - prefixLen].term then
            log := <iog[0], log[1], ... log[prefixLen- 1]>
        end if
    end if
    if prefixLen + suffix.length > log.length then
        for i := log.length - prefixLen to suffix.length- 1 do
            append sufix[i] to log
        end for
    end if

    if leaderCommit > commitLength then
        for i := commitLength to leaderCommit - 1 do
            deliver log[i].msg to the application
        end for
        commitLength := leaderCommit
    end if
end function
------------------------------------------------------------------------------
so append entries here is called, if we have checked that log is okay, and we want to append the new entries from the log request message to the follower's log.
and so the first thing we now need to check is it could be that the follower already has some of the log entries that contained within this message, and if so we need to check whether those are the same.


------------------------------------------------------------------------------
    if suffix.length> 0 ∧ log.length > prefixLen then
------------------------------------------------------------------------------
so first of all if the suffix is non-empty, so that means the log request message did contain new log entries.

and if the length of the followers log is longer than the prefix length, that is the follower already has some log entries go beyond the prefix.

so at this point, we have the suffix, the new log entries overlapping with the log entries that the follower already has.
in that case we're going to find the last log entry that we can compare between the follower state and the leader state.
------------------------------------------------------------------------------
        index := min(log.length, prefixLen + suffix.length) - 1
------------------------------------------------------------------------------
and the last that's going to be either the length of the follower's log minus 1, or it's going to be the length of the prefix plus the length of the suffix minus 1, whichever of those two is smaller. and that is going to be the index of the log entry that we're going to compare.


------------------------------------------------------------------------------
        if log[index].term ≠ suffix[index - prefixLen].term then
            log := <iog[0], log[1], ... log[prefixLen- 1]>
        end if
------------------------------------------------------------------------------
and for that particular index, we're going to compare the term number in the followers log to the term number in the corresponding entry in the suffix, in the new log entries that we received from the leader. and if those are not the same term number, that means we have an inconsistency in the log, and we have to truncate the log.
and so what we're going to do then is to actually keep only the length up only the followers log up to prefix length, and everything beyond prefix length we're going to throw away.
that is the correct thing to do here, because those previous log entries might have come from a previous leader, and they will not yet be committed, so a key property that raft ensures is that if a log entry is committed then it will never change and it won't be discarded, and it won't be removed by this truncate process here.
but a log entry that is not yet committed, it could happen that log entry gets removed as part of this truncation.

so if these term numbers are the same, then as i explained earlier, raft guarantees that then the logs are identical up to that point including that particular index, and in that case we don't need to truncate the logs because we know that the leaders log and the followers log are consistent with each other.



------------------------------------------------------------------------------
    if prefixLen + suffix.length > log.length then
        for i := log.length - prefixLen to suffix.length- 1 do
            append sufix[i] to log
        end for
    end if
------------------------------------------------------------------------------
either way, regardless of whether we need it to truncate or not, we can now append any new log entries to the log.
it could be now here that the suffix contains some log entries that the follower already has in which case we don't need to append them again, and we're just going to start off with the first entry in the suffix that the follower does not already have, and we go up to the last entry in the suffix, and we append each of them to the follower's log,

------------------------------------------------------------------------------

    if leaderCommit > commitLength then
        for i := commitLength to leaderCommit - 1 do
            deliver log[i].msg to the application
        end for
        commitLength := leaderCommit
    end if
------------------------------------------------------------------------------
now comes a variable called leader commits, I've not talked about this very much yet, but this will become important now when we talk about committing log entries, the leader commit is just an integer, and it tells us this leader commit variable this came as part of the log request message from the leader, commitLength is a variable that is stored under follower, and it keeps track of how many log entries counted from the start of the log have we committed so far.
and if the number of log entries that the leader has committed is greater than the log number of log entries that the follower has committed, that means more log entries are ready to be committed, so it's the leader that decides when a log entry can be committed by increasing this leader commits variable, and so if this leader commit is greater that means we can now take the log indexes starting from commit length, and all the way up to leader commit minus one, and those are ready to be committed, and to commit means here first of all we set the commit length to include those indexes, and also we deliver those messages to the application, so this is now the total order broadcast delivery as it happens on the followers, and total order broadcast delivery on the leader happens separately on the next slide

so that is actually all that happens on the followers


so let's completed the story from the point of view of the followers, we just need to finish the story from the point of view of the leader


=====================================================
Raft (8/9): leader receiving log acknowledgements
=====================================================
on receiving (LogResponse, follower, term, ack, success) at nodeId do
    if term = currentTerm A currentRole = leader then
        if success = true ^ ack: ≥ackedLength[follower] then
            sentLength[follower] := ack:
            ackedLength[ollower] := ack
            COMMITLOG ENTRIES()
        else if sentLength[follower] > 0 then
            sentLengthfollower] := sentLength[follower] - 1
            REPLICATELOG(nodeId, follower)
        end if
    else if term > currentTerm then
        currentTerrm := term
        currentRole := follower
        votedFor := null
        cancel election timer
    end if
end on


and so if you remember here the followers sent a log response message back to the leader. telling it whether it was, whether the follower was able to accept the new log entries and append them to the log.
==========================================
Raft (6/9): followers receiving messages
==========================================
part:
---------------------------------------------
    if term = currentTerm ∧ logOk then
        APPENDENTRIES(prefixLen, leaderCommit, suffix)
        ack := prefixLen + suffix.length
        send (LogResponse, nodeId, currentTerm, ack, true) to leaderId
    else
        send (LogResponse, nodeId, currentTerm, 0, false) to leaderId
    end if
---------------------------------------------
and this is now when the leader receives those log response messages from the follower, and now the leader needs to decide which log entries are ready to be committed.
so a log entry is ready to be committed if it's been acknowledged by a quorum of nodes in the system, when the leader receives one of these log response messages, as always when receiving a message the first thing it has to do is to check the term number.

so if the term number and the log response message is greater than the leader's term that means, "oh there's a new node with a higher term number as always we have to accept that term number, and transition to follower state, forget whoever we voted for in a previous term, and cancel the election timer, however in the case where the term number is correct, so the term number matches the leader's term number, and the leader in fact still the leader, then it can go ahead.
now first it has to check was the success field true, so this is the success field in the log response message that it received from the follower, and if this success field is true, and if the acknowledgement that was contained in that message is at least the number that was previously acknowledged by the same follower, that means the followers acknowledging new messages now.
you know if the messages get delivered out of order, it could happened that a message with a higher act is delivered first, and then a message with a lower act later. so this ensures that no matter which order the messages are delivered, everything ends up being fine.
so in the expected case, where the acknowledgement is greater then whatever the previous acknowledgement was, the leader can now record the fact that it has received an acknowledgement from this particular follower, and it does this by updating both the sent length variable and the act length variable to be that integer that is the number of acknowledged log entries from that particular follower.
and it then calls the commit log entries function which will be on the next slide to actually decide which log entries are ready to be committed.

on the other hand if this log response was not successful, then we have to check the sent length, and so if it was not successful, it could be that there was a gap in the log, so remember we split the log into a prefix and a suffix, the prefix we assumed to follow already has, but what if the follower lost part of its log, and there's actually a gap and it doesn't have the entire prefix, that's the case that we handle here, so in this case if the success was not true, then the sent length variable for the follower, we're just going to decrement that, so we're going to reduce it by one, and that means now we're going to shrink the length of the prefix by one, and we're going to send one more log entry to the follower on our next attempt, now if there's a large gap between what the log that the follower has, and the log that the leader has, this could take quite a few iterations where we just reduce the length of the prefix by one every single time, so you could imagine more efficient ways of doing this, but for now, we're just going to keep it not it's complicated enough as it is, we're not going to over complicate it, and we're just going to reduce this sent length by one, and call the replicate log function again. remember we saw replicate log earlier, and this is going to send all of the log entries that go beyond this sent length, and so this will ensure that eventually we will fill in any gap in the log, and eventually the follower will be able to apply the new log entries, because we've sent all of the missing log entries from the leader to the follower.


okay, and that is the leader side except for the commit log entries function, so that's the last one that we need to look at.
and this one here, it's now looks at this actedLength variable, remember in the actedlength variable we recorded for every follower, the number of log entries that follower has confirmed as having received.
==============================================
Raft (9/9): leader committing log entries
==============================================
Any log entries that have been acknowledged by a quorum of nodes are ready to be committed by the leader. When a log entry is committed, its message is delivered to the application.

function COMMITLOGENTRIES
    while commitLength < log.length do
        acks := 0
        for each node ∈ nodes do
            if ackedLength[node] > commitLength then
                acks := acks + 1
            end if
        end for

        if acks ≥ ⌈(|nodes| + 1)/2⌉ then
            deliver log[commitLength].msg to the application
            commitLength := commitLength + 1
        else
            break
        end if
    end while
end function
----------------------------------------------
and so here, we are now going to start off with the variable commit length, so that is commit length is the number of log entries counted from the start of the log that we have already committed, and now we want to see if there are any additional log entries that are also ready to be committed, and so as long as commit length is less than the length of the log, we initialize x to zero and then this x variable will count from how many followers including one and also the leader we have an acknowledgement, and so we're going to go through all of the nodes in the system, the leader and all of the followers, and we're going to check the act length variable for each of those nodes, and if its value is greater than the commitLength, then that means from the point of view of that particular node, it's okay to move the commitLength forward, so it has already acknowledged more log entries beyond the existing commitLength, and we're going to count that as an acknowledgement, and now we're going to see if the number of acknowledgements that we've received for the log entry at index commitLength, if that is greater than a majority, then it's ready for that log entry to be committed, and so in this case, we're now going to the do the total order broadcast delivery of the log end of the message at the log entry with index commitLength, that's going to be delivered to the application, this is on the leader.
and we're going to increment the value of the commitLength variable, and this new variable will then be sent out to all of the followers, the next time we call the replicate log function.
and so we keep going around this loop here, and committing log entries as long as we can reach this majority quorum, if at some point then we reach the point where we don't have a majority quorum of acknowledgements yet, then we just break out of the loop, because we have to wait for more log response messages before we can do further commits.


I know it's a huge amount of detail, it's really interesting to see that interplay between the leaders and the followers, always having to check the term number and so on, but you can see how by very carefully sequencing all of the things it is possible to actually achieve something like total order broadcast.