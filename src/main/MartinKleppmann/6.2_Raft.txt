I'm going to walk you through the entire raft consensus algorithm for performing total order broadcast
what I would like you to do through is to carefully understood and understand exactly how and why the algorithm works, because I find that principle of how the raft algorithm works are really instructive for thinking about state in a distributed system more generally.
=======================================================
Node state transitions in Raft
=======================================================
the core of the raft algorithm is a state machine where every node can be in what in one of three states either a follower, a candidate, or a leader.
and the state is always in a certain term, so there's always a certain term number, and a node can be deleted in a particular term.

when a node starts off starts up for the first time, it always goes into the follow-up state, and also if a node crashes and recovers and then when the nodes restarts and recover from the crash, it always goes back into the follower state regardless of which state it was in before the crash.
however all of the nodes start as followers eventually we need some node become the leader, and the way how a node becomes the leader is by first becoming a candidate. and so when a node detects that there has been no message from a leader for some amount of time a timeout elapses, and then a node will decide that okay it is going to stand as candidate in a particular term number, and it's within that term number, it's going to get votes from the other nodes. and it manages to get positive votes from a quorum of nodes in the system from majority, then it is able to transition into the leader state
however it could also happen that in the process of this election, the candidate discovers that there's a different node with a higher term number, and if it does so, then the candidate immediately steps back becomes follower again, and works with the node that has the higher term number, so a higher term number always take precedence.
it could also happen while a node in candidate state, it's doing the election, but maybe it's not able to communicate with a quorum of replicas right now, or quorum of nodes, and so it's timeout, so it simply doesn't receive a quorum of positive votes within the required time, and if so it will restart its election again with a higher term number, so it remains candidate and starts again with a higher term number.
likewise it could happen if the leader is just doing its leadering job, it might discover that there's a node with a higher term number, perhaps the system has been partitioned, so that some subset of nodes have elected with a new leader with a a higher term number in the meantime, and if so the leader will always step back and become a follower again immediately upon discovering some other node with a higher term number. so we always have a peaceful transition of power in the raft algorithm from the lower term number to the higher term number.




here we start off with usual initialization of variables
========================================
Raft (1/9): initialisation
========================================
on initialisation do
    currentTerm := 0; votedFor := null
    log := <>; commitLength := 0
    currentRole := follower; currentLeader := null
    votesReceived := {}; sentLength := <); ack:edLength := <>
end on
-------------------------------------------------

-------------------------------------------------
on recovery from crash do
    currentRole := follower; currentLeader := null
    votesReceived := {}; sentLength := <>; ackedLength := <>
end on
-----------------------------------------------------

-----------------------------------------------------
on node nodeId suspects leader has failed, or on election timeout do
    currentTerm := currentTerm + 1; currentRole := candidate
    votedFor := nodeId; votesReceived := { nodeId}; lastTerm := 0
    if log.length > 0 then lastTerm := log[log.length - 1].term; end if
    msg := (VoteRequest, nodeId, current Term, log.length, last Term)
    for each node∈nodes: send msg to node
    start election timer
end on
-----------------------------------------------------



-----------------------------------------------------
these four variables currentTerm, votedFor, log and commitLength have to be stored in stable storage that is on disk, whereas the remaining five variables they can be in transient storage that they can be lost in the case of a crash. but the first four variable have to be preserved in the case of a crash, and you can see the crash recovery here, so the five remaining variables simply get reset to new fresh state if we recover from a crash,

when a node suspects that the leader has failed, it will become a candidate and it will start an election, that's what happens here, by the way, typically this timeout that the node uses before it suspects a leader to have failed randomized, and the purpose for that is to avoid having lots of nodes all trying to become candidate at the same time which is what would happen if all the nodes start up at the same time, and then have the same timeout before they start an election, so randomizing the timeout reduces the probability of having several elections at the same time.
so whenever that happens now so the node decides it's time to start an election, it increments the current term, it sets its current role to be the candidates state, and like in every good election everyone votes for themselves in an election, also in raft, the node that has just become a candidate votes for itself by setting this voted for variable to its own node id, and it has this set of node ids in which records the set of votes that it has received in favor of itself as a candidate, and it puts its own node id as the first member of that set of votes received, this variable lastTerm is initially zero, but you can see if the length of the log is greater than zero, then we set this last term variable, so let me explain first what the log is.

so the log you can see illustrated up here is an array, or a list, it's a sequence of log entries, each log entry consists of two parts, firstly a message, so this is the message that we want to deliver via total order broadcast, that's the whole thing that the purpose of the algorithm, and secondly a term number on every log entry, so this term number is the term number of the leader at the time when that leader added that particular entry to the log, it's in there in zero indexed array where log0 is the first log entry.
and log.length is the number of log entries in the log, and if the log is non-empty here, if the log.length greater than zero, than we're going to say that the last term is the term field of the last log entry, so log.length minus one is the index of the last entry in the log,
and so we take the term field of that last log entry, and set that to be the value of this variable.
and we then construct a message that will be sent to all of the nodes, and so the candidate sends the same message to all of the nodes. it's a message tagged with the message type vote request, saying "please vote for me", and the message contains the several fields it contains the node id of the candidate, it contains the current term after that term number has been incremented, it contains the length of the log on candidate, and it contains this lastTerm variable which as I just said is the term field of the last log entry in the candidates log.
it sends this same message to all of the nodes, and it starts the timer that might eventually timeout if it doesn't manage to do the election successfully





so that's the candidate, let's see what happens on the other nodes that receive one of these wrote request messages
==============================
Raft (2/9): voting on a new leader
==============================
c for candidate

on receiving (VoteRequest, cId, cTerm, cLogLength, cLog Term) at node nodeId do
    if cTerm > current Term then
        currentTerm := cTerm; currentRole := follower
        votedFor := null
    end if
    lastTerm := 0
    if log.length > 0 then lastTerm := log log.[length - 1].term; end if
    logOk := (cLogTerm > lastTerm) V
             (cLogTerm = lastTerm ∧ cLogLength >= log.length)

    іf сТеrm = сurrеntТеrm ∧ lоgОk ∧ vоtеdFоr ∈ [ сІd, null] thеn
        votedFor := cId
        send(VoteResponse, nodeId, currentTerm, true) to node cId
    else
        send(VoteResponse, nodeId, currentTerm, false) to node cId
    end if
end on
---------------------------------------------------------------------------------------
so now we're one of the other nodes that has received a message from the candidate, and we have the id of the candidate(cId), we have the term number of the candidate(cTerm), the length of the candidate's log(cLogLength), and the term number in candidates last log entry(cLogTerm),
and first thing we're going to do when receiving a vote request message is to compare the candidate term to the current term of the recipient of this message, and if the candidate's term is greater than the current term of the recipient,

then we move forward and join then term of the candidate, so we do that by setting the recipient's current term to be the candidates term to transition into the follower state regardless of what the node's previous state was,
and this voted for variable gets set to null which mean that we have not yet voted for any candidate in the current term because we just change the current term. however, we might vote for that candidate in a minute.

 so next, we set up this variable lastTerm, very similar to the way we did on the candidate, and that is we look at the last log entry on the recipient of this vote request message, we get the term number in that last log entry, and we set that to be this lastTerm variable, now what we need to do is to check if the candidates log is up to date with our own log, the reason for that is that we don't want a candidate with an outdated log become the leader, and exactly what outdated means will become apparent later, but it's crucial that we want the candidates log to reflect all the updates that at least the quorum of the other nodes have seen, so you don't end up with a leader whose log is really outdated, because that might lead to the loss of some messages, we have this log ok variable here which will contain a boolean which tell us whether the current node thinks the candidate's log is okay to vote in favor of, and so there are two criteria here, first of all, if the logTerm of the candidate, so the term number that appears in the last log entry of the candidate if that term number is greater than the term number of the log entry on the recipient of this vote request message, then we consider the log to be okay. secondly anther way for the log to be okay is for the log terms in the last log entry to be the same, but for the candidates to have a log that is at least as long as the log of the recipient of this vote request message, so one of those things needs to be true either or, and if so then the log is okay, so we will now vote for this candidate if three criteria will hold firstly if the candidate's term equals the current term, that is it's not in some outdated term, we haven't seen any other node with a higher term number, secondly if the candidates' log is okay ,and thirdly if we have not yet voted for any other candidate in the current term , so this voted for variable would be null if we have not yet voted at all for any candidate in the current term, or it could be cid if we've already voted for the same candidate it's okay to vote several times for the same candidate in a single term, but we must not vote for two different candidates within the same term, so if all those three criteria are true, then we can vote in favor of this candidate, we weill do that by first setting our voted four variable to cid to remember the fact that we have voted for the candidate, and then we send a vote response message back to the candidate and this is going to contain node id of the node doing the vote. it's going to contain the current term number so we know which term this election is for and the value true to indicate that it's a vote approval in favor of this candidate,
on the other hand if any of those things are not true, then we send a vote response with a false field back to the candidate, telling it that we are not voting in favor of this candidate.



==========================================
Raft (3/9): collecting votes
==========================================
on receiving (VoteResponse, voterId, term, granted) at nodeId do
    if currentRole = candidate A term = current Term A granted then
        votesReceived := votesReceived ∪{ voterId}
        if votesReceived| ≥「(|nodes|+ 1)/2] then
            currentRole := leader; currentLeader := nodeId
            cancel election timer
            for each follower∈nodes \ { nodeId} do
                sentLength[follower] := log.length
                ackedLength[follower] := 0
                REPLICATELOG( nodeId, follower)
            end for
        end if
    else if term > current Term then
        currentTerm := term
        currentRole := follower
        votedFor := null
        cancel election timer
    end if
end on























