time, clocks, and ordering of events

Distributed systems often need to measure time, e.g.: .
    Schedulers, timeouts, failure detectors, retry timers
    Performance measurements, statistics, profiling
    Log files & databases: record when an event occurred
    Data with time-limited validity (e.g. cache entries )
    Determining order of events across several nodes
dig www.cst.com.ac.uk

We distinguish two types of clock:
    physical clocks: count number of seconds elapsed
    logical clocks: count events, e.g. messages sent

in distributed systems, a clock is sth that you can ask for a timestamp, so it tells you what the current time is and the current time is represented as a timestamp which might be the current date and time.

NB. Clock in digital electronics (oscillator)
!= clock in distributed systems source of timestamps)


Physical clocks include analogue/mechanical clocks based on pendulums or similar mechanisms
and digital clocks based e.g. on a vibrating quartz crystal

the most computers implement clocks nowadays is using quartz crystals.
silicon dioxide

it resonates at a certain frequency, the frequency at which it resonates can be tuned by cutting bits of the crystal using lasers

Piezoelectric effect:
mechanical force <==> electric field
if you apply an electric field to it, it induces a mechanical strain in the material, and also the other way if you apply a force to it then it creates an electric field.
you can use this interplay between the mechanical motion and the electric field in order to create a fairly accurate oscillator that resonates at a fairly accurate frequency, so there's a little of electronics around the quartz crystal.
but essentially it produces a signal with a certain fixed frequency, this frequency is quite predictable and this makes quartz clocks quite accurate but are certainly not perfect,
because there are always going to be certain manufacturing difference between one crystal and another, they won't oscillate at precisely the same frequency, there will be a little of an error.
moreover, the resonant frequency of a quartz crystal actually depends on the temperature. The crystals that used for quartz oscillators are tuned, and they're selected and created in such a way that their frequency is quite stable around room temperature, around 20 to 25 degrees c, but as you deviate from this temperature significantly, there's actually a quadratic decrease(呈倒二次函数形状, ax^2 + bx + c = y, a < 0的图像) in the clock speed, so if you're in a very hot server room for example, where you might reach significantly higher temperatures than your typical room temperature, then this actually can have a significant impact on the frequency at which the clock is running. so the clock speed is measured in parts per million usually, this just like percent but rather than dividing by 100 we divide by million, and so you can work out like if you have one ppm error that would mean that the clocks goes wrong by about 32 seconds per year, now most quartz clocks will be like 20 ppm or something like that order of magnitude of course depending on the temperature, as a rule of thumb probably most clock errors will be below 50 ppm


atomic clocks are based on quantum mechanical effect, so they actually use cesium atoms of a certain isotope, any quantum mechanics atom have discrete energy levels, the difference between those energy levels corresponds to certain resonant frequencies of atom and there's one particular energy transition which is at a fairly friendly to measure nine gigahertz, so you get about nine oscillations of this per second, and this is actually how the second is now defined.

SI unit: International System of Units
The SI base units are the standard units of measurement defined by the International System of Units (SI)
==============
Quartz clock
==============
error: drift
One clock runs slightly fast, another slightly slow

clock drift: phenomenon where a clock gains or loses time compared to another clock
一个时钟与另一个时钟相比，时间增加或减少的现象

Drift measured in parts per million (ppm)
1 ppm = 1 microsecond/second = 86 ms/day = 32 s/year
Most computer clocks correct within ~ 50 ppm
The rate by which a clock runs fast or slow is called drift.


When greater accuracy is required, atomic clocks are used. These clocks are based on quantum mechanical properties of certain atoms, such as caesium or rubidium

=========================
GPS as time source
=========================
if you want a very precise clock signal, one way of getting that clock is actually to use gps, so the same system that you use smartphone to tell you where you are right now at map, it works by having a bunch of satellites that orbit the earth, and each satellite carries an atomic clock, broadcasts its current clock and its current location periodically, and so the gps receiver it receives the signals from several of these satellites, it calculates the time difference between when the signal was sent by the satellite and when the signal was received by your phone, and from the time distance and the speed of light it can work out the actual distance in space between you and the satellite, and from that it can work out where you are.
now there's a lot of details that go into making this accurate, but for our purposes well you know all we're actually interested in right now is time not location, and you can use gps satellites as a very accurate way of getting time and clocks. now this does rely on being able to actually pick up teh signal from the satellite so if you're in the data center there's probably so much shielding and electromagnetic interference that you can't actually pick up the signal, so you have to put an antenna on the roof of the data center, but this is something that people actually do as a way of getting accurate clocks

===============================
coordinated universal time(UTC)
===============================
how is time defined?
you might have come across the term UTC the coordinated universal time(UTC) which is the reference time that is used for all of our time zones we use nowadays.


you've probably come across the term GMT greenwich meantime, which unfortunately the meaning of that has changed over time, its original meaning was time based on astronomical observations. so it was literally when is the sun in the south, if you are looking at the sun from greenwich observatory. so you can literally go to greenwich in southeast london and visit the observatory there, and see meridian at which it was defined that when the sun is in the south as seen from this particular place, then it is noon. now it varied a little over the course of the year so that way we actually average this over the course of the year, but the idea is still, this is time based on astronomical observations.


International Atomic Time(TAI): using quantum mechanics

Problem: speed of Earth's rotation is not constant
Compromise: UTC is TAI with corrections to account for Earth rotation


and so the result is that we want to use atomic time because it's much more precise then this wobbly earth time, but at the same we want our time to be consistent with how the earth rotates around its axis.
the compromise is utc, we take international atomic time and we apply some corrections to it based on astronomy and that will give us a time that is founded on quantum mechanics but still consistent with astronomical observations.

summertime, wintertime, all of these are defined as offsets to utc. so if you're on the east coast US, for example, you'll be in like utc plus five.

Time zones and daylight savings time are offsets to UTC

how does this correction from atomic time to utc look like, the answer is the correction takes the form of leap seconds. (just like leap year concept)

a leap second is an extra second that can be either inserted or removed on a certain date. so every year there are typically two dates on which a leap second may or may not happen, that is the 30th of june and the 31th of december in principle.

so if there's a second subtracted, and then there is no 23:59:59 second, the clock goes 48, and then immediately jumps to zero after one second, so 59 second simply skipped. or we can have a regular second. or we can have an additional second in which the clock goes from 59:59 to 60 then to zero after two seconds.

How computers represent timestamps
T wo most common representations:
1. Unix time: number of seconds since 1 January 1970 00:00:00 UTC (it is called the unix "epoch"), not counting leap seconds
2. ISO 8601: year, month, day, hour, minute, second, and timezone offset relative to UTC
example: 2020-11-09T09 : 50: 17+00:00

==================
How most software deals with leap seconds
==================
by ignoring them

However, OS and DistSys often need timings with sub-second accuracy.
one second can be rather significant and that means we do actually have to care about these leap seconds which brings us to the solution of the little puzzle, that i presented at the beginning of this lecture which is what is on earth happened on the 30th of june 2012, for all of these systems to go down at the same time, the answer was a leap second happened, and there hadn't been a leap second for a couple of years before that, so during those years of course, the linux kernel and all other software were updated and the bug was introduced, and as a result there was actually a live lock condition sort of when the leap second happened the system went into live lock and so it was just spinning 100 CPU and not getting any useful work done, and even rebooting the computers didn't actually help, the administrator figured out when was that you actually had to reset the system clock, and that somehow cleared out the bad state in the linux kernel, and allowed us to fix those computers again. you can imagine that was a really bad day for administrators of these systems who rebooted the systems and they still didn't work,

==================
live lock
线程1可以使用资源，但它很礼貌，让其他线程先使用资源，
线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。
这样你让我，我让你，最后两个线程都无法使用资源。

CPU一直占用但是程序没有make progress.

考虑一个场景：
进程P1占有A请求B，进程P1占有B请求A。如果是等待式的请求，两者都会陷入无尽的等待中。这是死锁。
如果请求不是等待式的，而是一旦发现资源被占有就失败，整个请求取消（回滚）并重新开始。此时P1放弃占有A重新开始，P2放弃占有B重新开始。则P1、P2可能会出现重复不断的开始-回滚循环。这种情况我们称之为活锁。
相比死锁，活锁更难检测，也更浪费资源（重复不断的开始-回滚循环）。

死锁如果是两个不动的齿轮，活锁大概就是你低头走在路上，正好快要碰上一个美女，你马上往左边垮了一步，但美女也正好往右边跨了一步，不断循环，最后谁都过不去。

oracle java tutorial 里面有个类比：
This is comparable to two people attempting to pass each other in a corridor: Alphonse moves to
his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass. Seeing that they are still blocking each other, Alphone moves to his right, while Gaston moves to his left. They're still blocking each other, so...
https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html
==================
Pragmatic solution: 'smear'(spread out)
the leap second over the course of a day

the solution is now more widely which tries to get around this problem that most software does not know how to deal with leap seconds correctly, and solution is called smearing, leap second smearing which is rather than if we're going to insert a leap second rather than inserting it at one particular moment, how about we just spread that leap second out over the course of a whole day.
so let's say for example 12 hours before and 12 hours after the leap second is supposed to be introduced, we just slow down the clocks ever so slightly, enough so that then in total, one additional second has elapsed over the course of this period, but without this discontinuity of time where we've added that extra second which confuses all of the software.
it's a kind of hack, it's not a elegant solution, but it might be pragmatically the best that we can come up with


