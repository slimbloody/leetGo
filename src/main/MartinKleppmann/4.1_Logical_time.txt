Broadcast protocols and logical time

===========================
Physical timestamps inconsistent with causality
===========================
this is a problem with physical clocks even after we've gone to all of this efforts to synchronized them using NTP, even then it could happen that you get these inconsistencies with causality, so this is where logical clocks come in.


===============
Logical vs physical clocks
===============
1. Physical clock: count number of seconds elapsed
2. Logical clock: count number of events occurred

Physical timestamps: useful for many things, but may be inconsistent with causality.

Logical clocks: designed to capture causal dependencies.
(e1 -> e2) -> (T(e1) < T(e2))

logical clocks are an alternative definition of clocks that are used in distributed systems which are specifically designed to capture the casual relationships between the events that happen in a system, and so logical clocks are sort of clocks, they're not clocks in the sense of measuring how long it's been, measuring how far the sun has, at the earth has turned around the sun measuring how far this the earth has rotated around, it's own axis those kind of things. that's all physical time.
in logical time we're not actually interested in how many seconds have elapsed, instead what we're interested in is how many events have occurred, so logical timestamps are essentially just counters that we increment every time when something happens, and so this means they do move forwards in time, they get greater as stuff happens, but they don't have a direct relationship to physical time.



so the key thing that we want of a logical clock, is that it captures causality, it captures the happens before relationship, in particular, if event one happened before event two, then we want the timestamp of event one to be less than the timestamp of event two. this is like a minimum basic thing that we expect of our logical clocks.

and we're going to look at two different constructions of logical clocks, lamport clocks and vector clocks.

We will look at two types of logical clocks:
1. Lamport clocks
2. Vector clocks

both of these satisfy the need to capture causality, but they have different properties, in other areas as we shall see.


======================
Lamport clocks algorithm: these are named after lamport who published this algorithm in about 1978
======================
on initialisation do
    t := 0        (each node has its own local variable t)
end on
on any event occurring at the local node do
    t := t + 1
end on

on request to send message m do
    t := t + 1; send (t, m) via the underlying network link
end on

on receiving (t', m) via the underlying network link do
    t := max(t, t')+ 1
    deliver m to the application
end on

the algorithms starts at every node, we have a variable that we call t, and this variable is initialized to zero when we start up the system, and each node has its own copy of this variable, each node has its own t

and every time when some events occurs at a node, we just increment t, so an event could be some local execution step taking place so it could be sending a message or receiving message, in all of these cases we just increment t

everytime we want to send over the network, we increment t as usual as for any local event, and also we take the value of t after incrementing it, and we attach that to the message, so the message we send is actually this pair of a timestamp and the actual message, and that is what gets centered with the network

now when one of these pairs is received, at the other end of the node that is receiving the message takes the timestamp out of message, t prime(t') is the timestamp in the message, and it looks at its own local variable t, and it updates t to be the maximum of either its own local existing timestamp or the timestamp of the message plus one, incrementing it again like for every local event
so after this has been done we've got updated value t and we deliver the message to the application
本地时间是t, request里面拆出来的数据是t', 把两者中大的值设为t的值


==============================
Lamport clocks in words
==============================
1. Each node maintains a counter t, incremented on every local event e
2. Let L(e) be the value of t after that increment
3. Attach current t to messages sent over network
4. Recipient moves its clock forward to timestamp in the message (if greater than local counter), then increments


so we have this counter t here on each node and we can associate a particular value of t with every event, so let's say some local event occurred and it called that event e,
for every local event we increment the counter so after that increment we take the value of that counter, and associated that with that event e and call that l of e for lamport lock.
as i said we attach those values over on the message that we send over the network as well



Properties of this scheme:
1. If a -> b, then L(a) < L(b)
first of all, if event a happened before event b, then this scheme guarantees that the lamport timestamp of event a is strictly less than lamport timestamp of event b
todo: exercise in the lecture note that asks you to prove that this is indeed the case

2. However, L(a) < L(b) does not imply a -> b
however, the converse is not true. so if we have two lamport timestamp and we compare them and we find that l of a is less than l of b, that does not imply that a happened before b, it could also be the case that a and b were concurrent, so the lamport timestamp don't allow to tell whether a or b working current or if a happened before b, the only thing we can do is we can rule out that b happened before a, because if b happened before a then the timestamp would have to be the other way around.


3. Possible that L(a)= L(b) for a≠b
that we have two different events with the same timestamp, there's nothing preventing this,


===============
Lamport clocks example
===============
there are two different events with the same timestamp three, and also two different events with the timestamp one.
and so one thing we might want to do is to have timestamps that uniquely identify events in the entire system and we can do this by combining the lamport timestamp with the name of node at which that particular event occurred.

Let N(e) be the node at which event e occurred.
Then the pair (L(e), N(e)) uniquely identifies event e.

within the scope of A, each of events has a unique timestamp, because we always increment, we never generate two events at the same node with the same timestamp, and so therefore within one particular node, each event timestamp is unique, if we assume each node has a unique name, we combine the lamport timestamp of an event with the name of the node at which that event occurred. those two taken together will uniquely identify a particular event that combination is a unique identifier


so we could actually update this diagram here and instead of just having the timestamp at each we have the pair of the timestamp and the node, and now we can see here this event here has an identifier of three comma A(3, A), whereas this one here is three comma B (3, B). so they're no longer the same.

and now there's one more thing that we can do with lamport timestamps and this is extremely useful. and that is we can define a total order using those


(a<b) <=> (L(a)< L(b) V (L(a)= L(b) ^ N(a) < N(b))
The order is casual: (a < b) <=> (a < b)

we can define that a is less than b according to this little curly less than symbol symbol,

a is less than b
if and only if
the lamport timestamp of a is less than the timestamp of a lamport timestamp of b,
or
if a and b have the same timestamp, but the name of the event a is the less than the node name of event b

so this assuming we have some way of comparing node names like a b and c, we could just have like a lexical graphic comparison of those, so that a comes before b and b comes before c for example, so this now means we can define an ordering on these events by first of all looking at their lamport timestamp, and if the timestamp are the same, we break the ties using the name of the nodes.

this ordering here is a total order that means for any two events, if they're distinct events it is always the case that either a is less than b or b is less than a, so it's not a partial order that happens before relationship was partial order in which some events are incomparable if they are concurrent but here this is a total order which means any event that happened anywhere in the system we can always put them one after the other according to this order, and this order is consistent with causality which means that if event a happened before event b then it is always the case that a is less than b according to the total order and that follows directly from the fact that the lamport timestamps are consistent with causality.

they(lamport timestamp) essentially give a way attaching timestamps to all of the events in a system in a way that captures that happens before relationships, so we can now define this total order using their timestamps, so we can use the timestamps as a way of detecting the order of the events that happened in the system.




==============
Vector clocks
==============
limitation of Lamport clock:
1.
Given Lamport timestamps L(a) and L(b) with L(a) < L(b)
we can't tell whether a -> b or a || b(current).


If we want to detect which events are concurrent where one happened before the other, we need vector clocks:

