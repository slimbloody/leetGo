=============================================
Broadcast protocols and logical time
=============================================

===========================
Physical timestamps inconsistent with causality
===========================
what could happen with physical clocks is that the timestamp of message one ends up being greater than the timestamp of message two, so it could be the case that those timestamps are inconsistent with the order that we intuitively expect of those two messages, that those messages are inconsistency with causality.
this is a problem with physical clocks even after we've gone to all of this efforts to synchronized them using NTP, even then it could happen that you get these inconsistencies with causality, so this is where logical clocks come in.


==============================
Logical vs physical clocks
==============================
1. Physical clock: count number of seconds elapsed
2. Logical clock: count number of events occurred

Physical timestamps: useful for many things, but may be inconsistent with causality.

Logical clocks: designed to capture causal dependencies.
(e1 -> e2) -> (T(e1) < T(e2))

logical clocks are an alternative definition of clocks that are used in distributed systems which are specifically designed to capture the casual relationships between the events that happen in a system.
 and so logical clocks are sort of clocks, they're not clocks in the sense of measuring how long it's been, measuring how far the sun has at the earth has turned around the sun, measuring how far this the earth has rotated around it's own axis, those kind of things. that's all physical time.
in logical time we're not actually interested in how many seconds have elapsed, instead what we're interested in is how many events have occurred, so logical timestamps are essentially just counters that we increment every time when something happens, and so this means they do move forwards in time, they get greater as stuff happens, but they don't have a direct relationship to physical time.


so the key thing that we want of a logical clock is that it captures causality, it captures the happens before relationship, in particular, if event one happened before event two, then we want the timestamp of event one to be less than the timestamp of event two. this is like a minimum basic thing that we expect of our logical clocks.

and we're going to look at two different constructions of logical clocks, lamport clocks and vector clocks.

We will look at two types of logical clocks:
1. Lamport clocks
2. Vector clocks

both of these satisfy this need to capture causality, but they have slightly different properties, in other areas as we shall see.

======================
Lamport clocks algorithm: these are named after lamport who published this algorithm in about 1978
======================
---------------------------------------------------------
on initialisation do
    t := 0        (each node has its own local variable t)
end on
---------------------------------------------------------
the algorithms starts at every node, we have a variable that we call t, and this variable is initialized to zero when we start up the system, and each node has its own copy of this variable, each node has its own t

---------------------------------------------------------
on any event occurring at the local node do
    t := t + 1
end on
---------------------------------------------------------
and every time when some events occurs at a node, we just increment t, so an event could be some local execution step taking place so it could be sending a message or receiving message, in all of these cases we just increment t

---------------------------------------------------------
on request to send message m do
    t := t + 1; send (t, m) via the underlying network link
end on
---------------------------------------------------------
everytime we want to send over the network, we increment t as usual as for any local event, and also we take the value of t after incrementing it, and we attach that to the message, so the message we send is actually this pair of a timestamp and the actual message, and that is what gets sent over the network

---------------------------------------------------------
on receiving (t', m) via the underlying network link do
    t := max(t, t')+ 1
    deliver m to the application
end on
---------------------------------------------------------
now when one of these pairs is received, at the other end of the node that is receiving the message, takes the timestamp out of message, t prime(t') is the timestamp in the message, and it looks at its own local variable t, and it updates t to be the maximum of either its own local existing timestamp or the timestamp of the message plus one, incrementing it again like for every local event

so after this has been done we've got updated value t and we deliver the message to the application
本地时间是t, request里面拆出来的数据是t', 把两者中大的值设为t的值


==============================
Lamport clocks in words
==============================
1. Each node maintains a counter t, incremented on every local event e
2. Let L(e) be the value of t after that increment
3. Attach current t to messages sent over network
4. Recipient moves its clock forward to timestamp in the message (if greater than local counter), then increments


so we have this counter t here on each node and we can associate a particular value of t with every event, so let's say some local event occurred and it called that event e,
for every local event we increment the counter so after that increment we take the value of that counter, and associated that with that event e and call that l of e for lamport lock.
as i said we attach those values over on the message that we send over the network as well



Properties of this scheme:
1. If a -> b, then L(a) < L(b)
first of all, if event a happened before event b, then this scheme guarantees that the lamport timestamp of event a is strictly less than lamport timestamp of event b
todo: exercise in the lecture note that asks you to prove that this is indeed the case

2. However, L(a) < L(b) does not imply a -> b
however, the converse is not true. so if we have two lamport timestamp and we compare them and we find that l of a is less than l of b, that does not imply that a happened before b, it could also be the case that a and b were concurrent, so the lamport timestamp don't allow to tell whether a or b working current or if a happened before b, the only thing we can do is we can rule out that b happened before a, because if b happened before a then the timestamp would have to be the other way around.


3. Possible that L(a)= L(b) for a≠b
that we have two different events with the same timestamp, there's nothing preventing this,


===============
Lamport clocks example
===============
there are two different events with the same timestamp three, and also two different events with the timestamp one.
and so one thing we might want to do is to have timestamps that uniquely identify events in the entire system and we can do this by combining the lamport timestamp with the name of node at which that particular event occurred.

Let N(e) be the node at which event e occurred.
Then the pair (L(e), N(e)) uniquely identifies event e.

within the scope of A, each of events has a unique timestamp, because we always increment, we never generate two events at the same node with the same timestamp, and so therefore within one particular node, each event timestamp is unique, if we assume each node has a unique name, we combine the lamport timestamp of an event with the name of the node at which that event occurred. those two taken together will uniquely identify a particular event that combination is a unique identifier


so we could actually update this diagram here and instead of just having the timestamp at each we have the pair of the timestamp and the node, and now we can see here this event here has an identifier of three comma A(3, A), whereas this one here is three comma B (3, B). so they're no longer the same.

and now there's one more thing that we can do with lamport timestamps and this is extremely useful. and that is we can define a total order using those


(a<b) <=> (L(a)< L(b) V (L(a)= L(b) ^ N(a) < N(b))
The order is casual: (a < b) <=> (a < b)

we can define that a is less than b according to this little curly less than symbol symbol,

a is less than b
if and only if
the lamport timestamp of a is less than the timestamp of a lamport timestamp of b,
or
if a and b have the same timestamp, but the name of the event a is the less than the node name of event b

so this assuming we have some way of comparing node names like a b and c, we could just have like a lexical graphic comparison of those, so that a comes before b and b comes before c for example, so this now means we can define an ordering on these events by first of all looking at their lamport timestamp, and if the timestamp are the same, we break the ties using the name of the nodes.

this ordering here is a total order that means for any two events, if they're distinct events it is always the case that either a is less than b or b is less than a, so it's not a partial order that happens before relationship was partial order in which some events are incomparable if they are concurrent but here this is a total order which means any event that happened anywhere in the system we can always put them one after the other according to this order, and this order is consistent with causality which means that if event a happened before event b then it is always the case that a is less than b according to the total order and that follows directly from the fact that the lamport timestamps are consistent with causality.

they(lamport timestamp) essentially give a way attaching timestamps to all of the events in a system in a way that captures that happens before relationships, so we can now define this total order using their timestamps, so we can use the timestamps as a way of detecting the order of the events that happened in the system.




==============
Vector clocks
==============
limitation of Lamport clock:
Given Lamport timestamps L(a) and L(b) with L(a) < L(b)
we can't tell whether a -> b or a || b(current).


If we want to detect which events are concurrent, we need vector clocks:
we can tell that b did not happen before a because if that were the case the lamport timestamps would have to be the other way around. so we can tell something, but we can't actually tell the difference between two events that are concurrent and two events where one happened before the other. so it might also be useful to have a scheme of logical clocks in which it is possible to tell the difference between two events that concurrent and two events where one happened before the other, and this is where vector clocks come in.

1. Assume n nodes in the system, N = (N1, N2,..,Nn)
we're going to assume we know the names of all the nodes in the system, and we're going to put them in a vector, so this is an n-dimensional vector where each of the elements of the vector is one of the nodes in the system.

2. Vector timestamp of event a is V(a) = <t1,t2,...,tn〉
and we can define timestamps which are also vectors. in this case we have a timestamp here, consists of a sequence of integers, and we have one integer for every node in the system. now for every event rather than associating a single number with it we associate this vector of numbers with each event, and the meaning for these numbers is that for the i-th entry in this vector here ti that is the number of events that we have observed happening on node i. so we're counting events like we did in lamport timestamps, but now rather than mixing all of the nodes together into a single counter, we actually have a separate counter for every node, for the number of events that have occurred on that particular node.
3. ti is number of events observed by node N;
4. Each node has a current vector timestamp T
5. On event at node Ni, increment vector element T[i]



like lamport timestamp we can attach a vector timestamp on every event, and there are certain rules for updating these timestamps, so if we want to compute the timestamp for a particular event, the first thing we do is every time that an event occurs at a node ni, we increment the particular entry T[i], the particular element of that vector, corresponding to that particular node.

6. Attach current vector timestamp to each message
7. Recipient merges message vector into its local vector
like with the lamport timestamps we're going to attach vector clocks to messages that get sent over the network, and there's an algorithm for merging those.(vector clocks algorithm)

========================
vector clocks algorithm
========================
1.
on initialisation at node Ni do
T := <0,0,..,0>     => local variable at node N;
end on

every node locally has a timestamp, in this case, timestamps is not just an integer but it's a vector of integers, which starts off as being all zeros so we have one entry in this vector for each node in the system

2.
on any event occurring at node Ni do
    T[i] := T[i] + 1
end on

and every time a local event occurs somewhere in the system we're going to increment particular vector element corresponding to the node at which that event occurs, so Ni processes some event it increment its own entry in the vector.

3.
on request to send message m at node Ni do
    T[i] := T[i]+ 1;    send (T, m) via network
end on

when we want to send a message over the network again, we increment our own entry like the vector like for every local event, and then we attach the vector T to the message to consent of the network


4.
on receiving (T',m) at node N; via the network do
    T[j]:= max(T[j],T'[j]) for every j∈{1,...,n}
    T[il := T[i] + 1; deliver m to the application
end on

when we receive one to these messages over the network, say T prime is the timestamp in the message.
now we're going to merge the recipient nodes current local time T, with the timestamp in the message T prime, and the way we're going to merge those is we're going to go through the vectors element wise, and so we're going to take the first element of T and the first element of T prime, I'm going to take the maximum of those two and that becomes the first element of T. so element wise, we take the maximum and the result is this updated variable T here.
then again we increment the local entry in T and we deliver m to the application.

======================================
vector clocks example
======================================
The vector timestamp of an event e represents a set of events,
e and its causal dependencies: {e} ∪ {a | a -> e}
e union all of the events that happened before e, and so visually we can think of this diagram by traveling backwards in time and finding all of the events that we can reach through travelling backwards either on each node's individual execution order, or by going backwards from the receipt to the sending of messages.


one way of thinking about these vectors here is that a vector represents a set of events

For example, <2, 2, 0> represents the first two events from A, the first two events from B, and no events from C

there is a direct correspondence between vectors and the set of events in the system, the vector is essentially a way of summarizing a set of events that occurred in the system, simply by counting for each node from the start of that node's execution of how many events down do we go in that node's history

==================================
Vector clocks ordering
==================================
Define the following order on vector timestamps
(in a system with n nodes):
1. T = T'  iff  T[i]=T'[i]  for all i∈{,...,n}
2. T ≤ T'  iff  T[i]≤T'[i]  for all i∈{.,...,n}
3. T < T'  iff  T≤T'        and     T≠T'
we can define strict inequalities, strictly less than simply as being t less than or equal to t prime and not being equal, which means that there must be at least one element in which they differ, but they might be the same in all of the other elements
4. T || T'  iff  T !≤ T' and  T' !≤ T
two vector timestamp, neither is t less than or equal to t prime, nor is t prime less than or equal to t
in that case we say that t and t prime are incomparable

V(a)≤V(b) iff ({a}∪{e|e→a}) ⊆ ({b}∪{e|e→b})

vector clock of A here corresponds to the set of events of A plus all of the events that happened before a and the vector timestamp of B corresponds to the set of events b plus all of the events that happened before b, now this less than recall relationship on the vectors corresponds exactly to a subset relationship on those two sets of events, this gives you a nice way of reasoning about what these vectors actually mean, because since they are correspond to sets of event, there's a subset relationship between the two, and it might be the case that one is a subset of the other, or it might be the case that neither is a subset of the other because there are some elements that they don't have in common, and so now this order that we have defined on these vector timestamps is very useful because it corresponds exactly to the happens before relationship, so it gives us a partial order, and this partial order is consistence with causality

Properties of this order:
1. (V(a) <  V(b)) <=> (a -> b)
first of all, we have the fact that given two events a and b, the vector timestamp of a is strictly less than the vector timestamp of b, according to this order above here, if and only if a happened before b.
for lamport timestamp we only had a one-way implication, we had that if a happened before b, then the timestamp L(a) is less than L(b). but with vector clocks we have an if and only if relationship, it's a bidirectional implication
2. (V(a) =  V(b)) <=> (a =  b)
3. (V(a) || V(b)) <=> (a || b)




so what we have here using vector clocks is a way of computing that happens before relationship, so far that happens before relation has been essentially this abstract definition, we can by looking at the diagram of the events on paper, we can work out what thing happened before which other thing, but that's not an algorithm for computing it, whereas here with vector clocks, we actually have an algorithm for computing exactly which event happened before which other event, and we have a way of telling whether two events are concurrent or not.

