======================================
Lecture 7 Replica consistency
======================================

======================================
"Consistency"
======================================
A word that means many different things in different contexts!
1.
    ACID(in the context of transactions): a transaction transforms the database from one consistent state to another
    Here,“consistent” = satisfying application-specific invariants
    e.g."every course with students enrolled must have at least one lecturer"


    the meaning of consistency is a property of a database state, so we're saying that the database is in a consistent state, and if you apply a goods transaction to it then it moves the database from one consistent state into another, so here consistent really means that the state of the database satisfies certain invariants or certain constraints, that the application has set. as one example if you have a university database you might have a consistency requirement that whenever a course has at least one student enrolled in it then it must also have a lecturer, so it must not be without lecturer, for example, you could have those kinds of consistency properties, but this acid consistency is not actually what we're usually talking about in distributed systems.


2.
Read-after-write consistency (lecture 5)
if a client makes a write and then reads back what it has just written it should be able to see what is has just written, that has got nothing to do with the consistency in the sense of acid, it's a very different meaning of word
3.
Replication: replica should be "consistent" with other replicas
    "consistent" = in the same state? (when exactly?)
    "consistent" = read operations return same result?

what we often say is we want one replica to be consistent with another replica, which again raises the question of what exactly we mean, so does that mean the replicas are in the state in the same state, but when exactly do they have to be in the same state, they could be in the same state at different points in time for example, or in different states at the same time, we could express consistency in terms of what the results of read operations should be what we expect.


so i'm just saying there are lots of different forms of consistency, and no one true definition of consistency, there are in fact a whole bunch of different consistency models, and in this lecture we're going to look at some of those consistency model, and see the context in which they are useful, and how they are defined.

Consistency model: many to choose from



======================================
Distributed transactions
======================================
Recall atomicity in the context of ACID transactions:
    A transaction either commits or aborts
    If it commits, its updates are durable
    If it aborts, it has no visible side- effects
    ACID consistency (preserving invariants) relies on atomicity

so you've covered transactions in the first half of this course on concurrent system, and if you recall the acid properties, the A stands for atomicity, which means that if a transaction makes a bunch of updates to the database, then even if the database crashes or something goes wrong, either all of those updates are applied to the database, and they are made durable in which case the transaction is set to commit, or none of the updates take effect in which transaction is said to be aborted. so we have this kind of binary choice of a transaction either, it commits or it aborts, but we don't end up with this kind of half state where some of the transactions updates have happened and others have not have happened, and this is very important, because if you want to ensure something like consistency like the sense of acid, you do have to have atomicity as the foundation of that, because otherwise, you could end up with two changes that need to be coordinated in some way, and if only one of the two happens then you end up in an inconsistent state, that's why we need atomicity.



If the transaction updates data on multiple nodes, this implies:
    Either all nodes must commit, or all must abort
in distributed system, we might have a transaction that involves more than one node in distributed database for example, and in this type of system, we have to ensure atomicity across all of the nodes that are participating in transaction, so all of the nodes on which data is being read or written in the course of a transaction, and so we must ensure that the transaction either commits on all of the nodes, or it aborts on all of the nodes, so that would then give us atomicity for the transaction as a whole across all of the nodes.
moreover, if one of the nodes involved in the transaction crashes, then we also have to make sure that we abort the transaction on all other nodes, because the crash node cannot complete the transaction, it cannot commit the transaction, and this is known as the atomic commitment problem in distributed system, so you might think this looks kind of a bit similar to consensus, because what we want here is all of the nodes to agree on whether to commit or abort the transaction which kind of smells like consensus superficially.



==========================================
Atomic commit versus consensus
==========================================
Consensus                               Atomic commit
One or more nodes propose a value       Every node votes whether to commit or abort







